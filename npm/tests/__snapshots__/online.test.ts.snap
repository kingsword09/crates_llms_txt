{
  "libName": "clap",
  "version": "4.5.39",
  "sessions": [
    {
      "title": "4.5",
      "description": "",
      "link": "https://docs.rs/clap/4.5.39"
    },
    {
      "title": "multicall_busybox",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/multicall_busybox.rs"
    },
    {
      "title": "mod",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/mod.rs"
    },
    {
      "title": "mod",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_derive/mod.rs"
    },
    {
      "title": "cargo_example_derive",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/cargo_example_derive.rs"
    },
    {
      "title": "repl",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/repl.rs"
    },
    {
      "title": "lib",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/lib.rs"
    },
    {
      "title": "git_derive",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/git_derive.rs"
    },
    {
      "title": "multicall_hostname",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/multicall_hostname.rs"
    },
    {
      "title": "_tutorial",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_tutorial.rs"
    },
    {
      "title": "git",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/git.rs"
    },
    {
      "title": "escaped_positional",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/escaped_positional.rs"
    },
    {
      "title": "_faq",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_faq.rs"
    },
    {
      "title": "pacman",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/pacman.rs"
    },
    {
      "title": "find",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/find.rs"
    },
    {
      "title": "_tutorial",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_derive/_tutorial.rs"
    },
    {
      "title": "repl_derive",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/repl_derive.rs"
    },
    {
      "title": "cargo_example",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/cargo_example.rs"
    },
    {
      "title": "typed_derive",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/typed_derive.rs"
    },
    {
      "title": "_features",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_features.rs"
    },
    {
      "title": "escaped_positional_derive",
      "description": "",
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/escaped_positional_derive.rs"
    }
  ],
  "fullSessions": [
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/multicall_busybox.rs",
      "content": "# Example: busybox-like CLI (Builder API)\n\n```rust\nuse std::path::PathBuf;\nuse std::process::exit;\n\nuse clap::{value_parser, Arg, ArgAction, Command};\n\nfn applet_commands() -> [Command; 2] {\n    [\n        Command::new(\"true\").about(\"does nothing successfully\"),\n        Command::new(\"false\").about(\"does nothing unsuccessfully\"),\n    ]\n}\n\nfn main() {\n    let cmd = Command::new(env!(\"CARGO_CRATE_NAME\"))\n        .multicall(true)\n        .subcommand(\n            Command::new(\"busybox\")\n                .arg_required_else_help(true)\n                .subcommand_value_name(\"APPLET\")\n                .subcommand_help_heading(\"APPLETS\")\n                .arg(\n                    Arg::new(\"install\")\n                        .long(\"install\")\n                        .help(\"Install hardlinks for all subcommands in path\")\n                        .exclusive(true)\n                        .action(ArgAction::Set)\n                        .default_missing_value(\"/usr/local/bin\")\n                        .value_parser(value_parser!(PathBuf)),\n                )\n                .subcommands(applet_commands()),\n        )\n        .subcommands(applet_commands());\n\n    let matches = cmd.get_matches();\n    let mut subcommand = matches.subcommand();\n    if let Some((\"busybox\", cmd)) = subcommand {\n        if cmd.contains_id(\"install\") {\n            unimplemented!(\"Make hardlinks to the executable here\");\n        }\n        subcommand = cmd.subcommand();\n    }\n    match subcommand {\n        Some((\"false\", _)) => exit(1),\n        Some((\"true\", _)) => exit(0),\n        _ => unreachable!(\"parser should ensure only valid subcommand names are used\"),\n    }\n}\n```\n\nSee the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.\n\nThis example omits every command except true and false,\nwhich are the most trivial to implement,\n```console\n$ busybox true\n? 0\n\n$ busybox false\n? 1\n\n```\n*Note: without the links setup, we can't demonstrate the multicall behavior*\n\nBut includes the `--install` option as an example of why it can be useful\nfor the main program to take arguments that aren't applet subcommands.\n```console\n$ busybox --install\n? failed\n...\n\n```\n\nThough users must pass something:\n```console\n$ busybox\n? failed\nUsage: busybox [OPTIONS] [APPLET]\n\nAPPLETS:\n  true   does nothing successfully\n  false  does nothing unsuccessfully\n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n      --install <install>  Install hardlinks for all subcommands in path\n  -h, --help               Print help\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/mod.rs",
      "content": "# Documentation: Cookbook\n\nTyped arguments: [derive][typed_derive]\n- Topics:\n  - Custom `parse()`\n\nCustom cargo command: [builder][cargo_example], [derive][cargo_example_derive]\n- Topics:\n  - Subcommands\n  - Cargo plugins\n  - custom terminal [styles][crate::Command::styles] (colors)\n\nfind-like interface: [builder][find]\n- Topics:\n  - Position-sensitive flags\n\ngit-like interface: [builder][git], [derive][git_derive]\n- Topics:\n  - Subcommands\n  - External subcommands\n  - Optional subcommands\n  - Default subcommands\n  - [`last`][crate::Arg::last]\n\npacman-like interface: [builder][pacman]\n- Topics:\n  - Flag subcommands\n  - Conflicting arguments\n\nEscaped positionals with `--`: [builder][escaped_positional], [derive][escaped_positional_derive]\n\nMulti-call\n- busybox: [builder][multicall_busybox]\n  - Topics:\n    - Subcommands\n- hostname: [builder][multicall_hostname]\n  - Topics:\n    - Subcommands\n\nrepl: [builder][repl], [derive][repl_derive]\n- Topics:\n  - Read-Eval-Print Loops / Custom command lines"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_derive/mod.rs",
      "content": "# Documentation: Derive Reference\n\n1. [Overview](#overview)\n2. [Attributes](#attributes)\n    1. [Terminology](#terminology)\n    2. [Command Attributes](#command-attributes)\n    2. [ArgGroup Attributes](#arggroup-attributes)\n    3. [Arg Attributes](#arg-attributes)\n    4. [ValueEnum Attributes](#valueenum-attributes)\n    5. [Possible Value Attributes](#possible-value-attributes)\n3. [Field Types](#field-types)\n4. [Doc Comments](#doc-comments)\n5. [Mixing Builder and Derive APIs](#mixing-builder-and-derive-apis)\n6. [Tips](#tips)\n\n## Overview\n\nTo derive `clap` types, you need to enable the [`derive` feature flag][crate::_features].\n\nExample:\n```rust\nuse clap::Parser;\n\n/// Simple program to greet a person\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    /// Name of the person to greet\n    #[arg(short, long)]\n    name: String,\n\n    /// Number of times to greet\n    #[arg(short, long, default_value_t = 1)]\n    count: u8,\n}\n\nfn main() {\n    let args = Args::parse();\n\n    for _ in 0..args.count {\n        println!(\"Hello {}!\", args.name);\n    }\n}\n```\n\nLet's start by breaking down the anatomy of the derive attributes:\n```rust\nuse clap::{Parser, Args, Subcommand, ValueEnum};\n\n/// Doc comment\n#[derive(Parser)]\n#[command(CMD ATTRIBUTE)]\n#[group(GROUP ATTRIBUTE)]\nstruct Cli {\n    /// Doc comment\n    #[arg(ARG ATTRIBUTE)]\n    field: UserType,\n\n    #[arg(value_enum, ARG ATTRIBUTE...)]\n    field: EnumValues,\n\n    #[command(flatten)]\n    delegate: Struct,\n\n    #[command(subcommand)]\n    command: Command,\n}\n\n/// Doc comment\n#[derive(Args)]\n#[command(PARENT CMD ATTRIBUTE)]\n#[group(GROUP ATTRIBUTE)]\nstruct Struct {\n    /// Doc comment\n    #[command(ARG ATTRIBUTE)]\n    field: UserType,\n}\n\n/// Doc comment\n#[derive(Subcommand)]\n#[command(PARENT CMD ATTRIBUTE)]\nenum Command {\n    /// Doc comment\n    #[command(CMD ATTRIBUTE)]\n    Variant1(Struct),\n\n    /// Doc comment\n    #[command(CMD ATTRIBUTE)]\n    Variant2 {\n        /// Doc comment\n        #[arg(ARG ATTRIBUTE)]\n        field: UserType,\n    }\n}\n\n/// Doc comment\n#[derive(ValueEnum)]\n#[value(VALUE ENUM ATTRIBUTE)]\nenum EnumValues {\n    /// Doc comment\n    #[value(POSSIBLE VALUE ATTRIBUTE)]\n    Variant1,\n}\n\nfn main() {\n    let cli = Cli::parse();\n}\n```\n\nTraits:\n- [`Parser`][crate::Parser] parses arguments into a `struct` (arguments) or `enum` (subcommands).\n  - [`Args`][crate::Args] allows defining a set of re-usable arguments that get merged into their parent container.\n  - [`Subcommand`][crate::Subcommand] defines available subcommands.\n  - Subcommand arguments can be defined in a struct-variant or automatically flattened with a tuple-variant.\n- [`ValueEnum`][crate::ValueEnum] allows parsing a value directly into an `enum`, erroring on unsupported values.\n  - The derive doesn't work on enums that contain non-unit variants, unless they are skipped\n\n*See also the [derive tutorial][crate::_derive::_tutorial] and [cookbook][crate::_cookbook]*\n\n## Attributes\n\n### Terminology\n\n**Raw attributes** are forwarded directly to the underlying [`clap` builder][crate::builder].  Any\n[`Command`][crate::Command], [`Arg`][crate::Arg], or [`PossibleValue`][crate::builder::PossibleValue] method can be used as an attribute.\n\nRaw attributes come in two different syntaxes:\n```rust,ignore\n#[arg(\n    global = true, // name = arg form, neat for one-arg methods\n    required_if_eq(\"out\", \"file\") // name(arg1, arg2, ...) form.\n)]\n```\n\n- `method = arg` can only be used for methods which take only one argument.\n- `method(arg1, arg2)` can be used with any method.\n\nAs long as `method_name` is not one of the magical methods it will be\ntranslated into a mere method call.\n\n**Magic attributes** have post-processing done to them, whether that is\n- Providing of defaults\n- Special behavior is triggered off of it\n\nMagic attributes are more constrained in the syntax they support, usually just\n`<attr> = <value>` though some use `<attr>(<value>)` instead.  See the specific\nmagic attributes documentation for details.  This allows users to access the\nraw behavior of an attribute via `<attr>(<value>)` syntax.\n\n<div class=\"warning\">\n\n**NOTE:** Some attributes are inferred from [Arg Types](#arg-types) and [Doc\nComments](#doc-comments).  Explicit attributes take precedence over inferred\nattributes.\n\n</div>\n\n### Command Attributes\n\nThese correspond to a [`Command`][crate::Command] which is used for both top-level parsers and\nwhen defining subcommands.\n\n**Raw attributes:**  Any [`Command` method][crate::Command] can also be used as an attribute,\nsee [Terminology](#terminology) for syntax.\n- e.g. `#[command(arg_required_else_help(true))]` would translate to `cmd.arg_required_else_help(true)`\n\n**Magic attributes:**\n- `name  = <expr>`: [`Command::name`][crate::Command::name]\n  - When not present: [package `name`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field) (if on [`Parser`][crate::Parser] container), variant name (if on [`Subcommand`][crate::Subcommand] variant)\n- `version [= <expr>]`: [`Command::version`][crate::Command::version]\n  - When not present: no version set\n  - Without `<expr>`: defaults to [crate `version`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field)\n- `author [= <expr>]`: [`Command::author`][crate::Command::author]\n  - When not present: no author set\n  - Without `<expr>`: defaults to [crate `authors`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-authors-field)\n  - **NOTE:** A custom [`help_template`][crate::Command::help_template] is needed for author to show up.\n- `about [= <expr>]`: [`Command::about`][crate::Command::about]\n  - When not present: [Doc comment summary](#doc-comments)\n  - Without `<expr>`: [crate `description`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-description-field) ([`Parser`][crate::Parser] container)\n    - **TIP:** When a doc comment is also present, you most likely want to add\n      `#[arg(long_about = None)]` to clear the doc comment so only [`about`][crate::Command::about]\n      gets shown with both `-h` and `--help`.\n- `long_about[ = <expr>]`: [`Command::long_about`][crate::Command::long_about]\n  - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing\n  - When present without a value: [Doc comment](#doc-comments)\n- `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`about`][crate::Command::about] / [`long_about`][crate::Command::long_about]\n- `next_display_order`: [`Command::next_display_order`][crate::Command::next_display_order]\n- `next_help_heading`: [`Command::next_help_heading`][crate::Command::next_help_heading]\n  - When `flatten`ing [`Args`][crate::Args], this is scoped to just the args in this struct and any struct `flatten`ed into it\n- `rename_all = <string_literal>`: Override default field / variant name case conversion for [`Command::name`][crate::Command::name] / [`Arg::id`][crate::Arg::id]\n  - When not present: `\"kebab-case\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n- `rename_all_env = <string_literal>`: Override default field name case conversion for env variables for  [`Arg::env`][crate::Arg::env]\n  - When not present: `\"SCREAMING_SNAKE_CASE\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n\nAnd for [`Subcommand`][crate::Subcommand] variants:\n- `skip`: Ignore this variant\n- `flatten`: Delegates to the variant for more subcommands (must implement\n  [`Subcommand`][crate::Subcommand])\n- `subcommand`: Nest subcommands under the current set of subcommands (must implement\n  [`Subcommand`][crate::Subcommand])\n- `external_subcommand`: [`Command::allow_external_subcommand(true)`][crate::Command::allow_external_subcommands]\n  - Variant must be either `Variant(Vec<String>)` or `Variant(Vec<OsString>)`\n\nAnd for [`Args`][crate::Args] fields:\n- `flatten`: Delegates to the field for more arguments (must implement [`Args`][crate::Args])\n  - Only [`next_help_heading`][crate::Command::next_help_heading] can be used with `flatten`.  See\n    [clap-rs/clap#3269](https://github.com/clap-rs/clap/issues/3269) for why\n    arg attributes are not generally supported.\n  - **Tip:** Though we do apply a flattened [`Args`][crate::Args]'s Parent Command Attributes, this\n    makes reuse harder. Generally prefer putting the cmd attributes on the\n    [`Parser`][crate::Parser] or on the flattened field.\n- `subcommand`: Delegates definition of subcommands to the field (must implement\n  [`Subcommand`][crate::Subcommand])\n  - When `Option<T>`, the subcommand becomes optional\n\nSee [Configuring the Parser][_tutorial#configuring-the-parser] and\n[Subcommands][_tutorial#subcommands] from the tutorial.\n\n### ArgGroup Attributes\n\nThese correspond to the [`ArgGroup`][crate::ArgGroup] which is implicitly created for each\n`Args` derive.\n\n**Raw attributes:**  Any [`ArgGroup` method][crate::ArgGroup] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[group(required = true)]` would translate to `arg_group.required(true)`\n\n**Magic attributes**:\n- `id = <expr>`: [`ArgGroup::id`][crate::ArgGroup::id]\n  - When not present: struct's name is used\n- `skip [= <expr>]`: Ignore this field, filling in with `<expr>`\n  - Without `<expr>`: fills the field with `Default::default()`\n\nNote:\n- For `struct`s, [`multiple = true`][crate::ArgGroup::multiple] is implied\n- `enum` support is tracked at [#2621](https://github.com/clap-rs/clap/issues/2621)\n\nSee [Argument Relations][_tutorial#argument-relations] from the tutorial.\n\n### Arg Attributes\n\nThese correspond to a [`Arg`][crate::Arg].\nThe default state for a field without attributes is to be a positional argument with [behavior\ninferred from the field type](#arg-types).\n`#[arg(...)]` attributes allow overriding or extending those defaults.\n\n**Raw attributes:**  Any [`Arg` method][crate::Arg] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[arg(num_args(..=3))]` would translate to `arg.num_args(..=3)`\n\n**Magic attributes**:\n- `id = <expr>`: [`Arg::id`][crate::Arg::id]\n  - When not present: field's name is used\n- `value_parser [= <expr>]`: [`Arg::value_parser`][crate::Arg::value_parser]\n  - When not present: will auto-select an implementation based on the field type using\n    [`value_parser!`][crate::value_parser!]\n- `action [= <expr>]`: [`Arg::action`][crate::Arg::action]\n  - When not present: will auto-select an action based on the field type\n- `help = <expr>`: [`Arg::help`][crate::Arg::help]\n  - When not present: [Doc comment summary](#doc-comments)\n- `long_help[ = <expr>]`: [`Arg::long_help`][crate::Arg::long_help]\n  - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing\n  - When present without a value: [Doc comment](#doc-comments)\n- `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`help`][crate::Arg::help] / [`long_help`][crate::Arg::long_help]\n- `short [= <char>]`: [`Arg::short`][crate::Arg::short]\n  - When not present: no short set\n  - Without `<char>`: defaults to first character in the case-converted field name\n- `long [= <str>]`: [`Arg::long`][crate::Arg::long]\n  - When not present: no long set\n  - Without `<str>`: defaults to the case-converted field name\n- `env [= <str>]`: [`Arg::env`][crate::Arg::env] (needs [`env` feature][crate::_features] enabled)\n  - When not present: no env set\n  - Without `<str>`: defaults to the case-converted field name\n- `from_global`: Read a [`Arg::global`][crate::Arg::global] argument (raw attribute), regardless of what subcommand you are in\n- `value_enum`: Parse the value using the [`ValueEnum`][crate::ValueEnum]\n- `skip [= <expr>]`: Ignore this field, filling in with `<expr>`\n  - Without `<expr>`: fills the field with `Default::default()`\n- `default_value = <str>`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]\n- `default_value_t [= <expr>]`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires `std::fmt::Display` that roundtrips correctly with the\n    [`Arg::value_parser`][crate::Arg::value_parser] or `#[arg(value_enum)]`\n  - Without `<expr>`, relies on `Default::default()`\n- `default_values_t = <expr>`: [`Arg::default_values`][crate::Arg::default_values] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires field arg to be of type `Vec<T>` and `T` to implement `std::fmt::Display` or `#[arg(value_enum)]`\n  - `<expr>` must implement `IntoIterator<T>`\n- `default_value_os_t [= <expr>]`: [`Arg::default_value_os`][crate::Arg::default_value_os] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires `std::convert::Into<OsString>` or `#[arg(value_enum)]`\n  - Without `<expr>`, relies on `Default::default()`\n- `default_values_os_t = <expr>`: [`Arg::default_values_os`][crate::Arg::default_values_os] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires field arg to be of type `Vec<T>` and `T` to implement `std::convert::Into<OsString>` or `#[arg(value_enum)]`\n  - `<expr>` must implement `IntoIterator<T>`\n\nSee [Adding Arguments][_tutorial#adding-arguments] and [Validation][_tutorial#validation] from the\ntutorial.\n\n### ValueEnum Attributes\n\n- `rename_all = <string_literal>`: Override default field / variant name case conversion for [`PossibleValue::new`][crate::builder::PossibleValue]\n  - When not present: `\"kebab-case\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n\nSee [Enumerated values][_tutorial#enumerated-values] from the tutorial.\n\n### Possible Value Attributes\n\nThese correspond to a [`PossibleValue`][crate::builder::PossibleValue].\n\n**Raw attributes:**  Any [`PossibleValue` method][crate::builder::PossibleValue] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[value(alias(\"foo\"))]` would translate to `pv.alias(\"foo\")`\n\n**Magic attributes**:\n- `name = <expr>`: [`PossibleValue::new`][crate::builder::PossibleValue::new]\n  - When not present: case-converted field name is used\n- `help = <expr>`: [`PossibleValue::help`][crate::builder::PossibleValue::help]\n  - When not present: [Doc comment summary](#doc-comments)\n- `skip`: Ignore this variant\n\n## Field Types\n\n`clap` assumes some intent based on the type used.\n\n### Subcommand Types\n\n| Type                  | Effect              | Implies                                                   |\n|-----------------------|---------------------|-----------------------------------------------------------|\n| `Option<T>`           | optional subcommand |                                                           |\n| `T`                   | required subcommand | `.subcommand_required(true).arg_required_else_help(true)` |\n\n### Arg Types\n\n| Type                  | Effect                                               | Implies                                                     | Notes |\n|-----------------------|------------------------------------------------------|-------------------------------------------------------------|-------|\n| `()`                  | user-defined                                         | `.action(ArgAction::Set).required(false)`                   |       |\n| `bool`                | flag                                                 | `.action(ArgAction::SetTrue)`                               |       |\n| `Option<T>`           | optional argument                                    | `.action(ArgAction::Set).required(false)`                   |       |\n| `Option<Option<T>>`   | optional value for optional argument                 | `.action(ArgAction::Set).required(false).num_args(0..=1)`   |       |\n| `T`                   | required argument                                    | `.action(ArgAction::Set).required(!has_default)`            |       |\n| `Vec<T>`              | `0..` occurrences of argument                        | `.action(ArgAction::Append).required(false)`  |       |\n| `Option<Vec<T>>`      | `0..` occurrences of argument                        | `.action(ArgAction::Append).required(false)`  |       |\n| `Vec<Vec<T>>`         | `0..` occurrences of argument, grouped by occurrence | `.action(ArgAction::Append).required(false)`  | requires `unstable-v5` |\n| `Option<Vec<Vec<T>>>` | `0..` occurrences of argument, grouped by occurrence | `.action(ArgAction::Append).required(false)`  | requires `unstable-v5` |\n\nIn addition, [`.value_parser(value_parser!(T))`][crate::value_parser!] is called for each\nfield.\n\nNotes:\n- For custom type behavior, you can override the implied attributes/settings and/or set additional ones\n  - To force any inferred type (like `Vec<T>`) to be treated as `T`, you can refer to the type\n    by another means, like using `std::vec::Vec` instead of `Vec`.  For improving this, see\n    [#4626](https://github.com/clap-rs/clap/issues/4626).\n- `Option<Vec<T>>` and `Option<Vec<Vec<T>>` will be `None` instead of `vec![]` if no arguments are provided.\n  - This gives the user some flexibility in designing their argument, like with `num_args(0..)`\n- `Vec<Vec<T>>` will need [`Arg::num_args`][crate::Arg::num_args] set to be meaningful\n\n## Doc Comments\n\nIn clap, help messages for the whole binary can be specified\nvia [`Command::about`][crate::Command::about] and [`Command::long_about`][crate::Command::long_about] while help messages\nfor individual arguments can be specified via [`Arg::help`][crate::Arg::help] and [`Arg::long_help`][crate::Arg::long_help].\n\n`long_*` variants are used when user calls the program with\n`--help` and \"short\" variants are used with `-h` flag.\n\n```rust\n# use clap::Parser;\n\n#[derive(Parser)]\n#[command(about = \"I am a program and I work, just pass `-h`\", long_about = None)]\nstruct Foo {\n    #[arg(short, help = \"Pass `-h` and you'll see me!\")]\n    bar: String,\n}\n```\n\nFor convenience, doc comments can be used instead of raw methods\n(this example works exactly like the one above):\n\n```rust\n# use clap::Parser;\n\n#[derive(Parser)]\n/// I am a program and I work, just pass `-h`\nstruct Foo {\n    /// Pass `-h` and you'll see me!\n    bar: String,\n}\n```\n\n<div class=\"warning\">\n\n**NOTE:** Attributes have priority over doc comments!\n\n**Top level doc comments always generate `Command::about/long_about` calls!**\nIf you really want to use the `Command::about/long_about` methods (you likely don't),\nuse the `about` / `long_about` attributes to override the calls generated from\nthe doc comment.  To clear `long_about`, you can use\n`#[command(long_about = None)]`.\n\n</div>\n\n### Pre-processing\n\n```rust\n# use clap::Parser;\n#[derive(Parser)]\n/// Hi there, I'm Robo!\n///\n/// I like beeping, stumbling, eating your electricity,\n/// and making records of you singing in a shower.\n/// Pay up, or I'll upload it to youtube!\nstruct Robo {\n    /// Call my brother SkyNet.\n    ///\n    /// I am artificial superintelligence. I won't rest\n    /// until I'll have destroyed humanity. Enjoy your\n    /// pathetic existence, you mere mortals.\n    #[arg(long, action)]\n    kill_all_humans: bool,\n}\n```\n\nA doc comment consists of three parts:\n- Short summary\n- A blank line (whitespace only)\n- Detailed description, all the rest\n\nThe summary corresponds with `Command::about` / `Arg::help`.  When a blank line is\npresent, the whole doc comment will be passed to `Command::long_about` /\n`Arg::long_help`.  Or in other words, a doc may result in just a `Command::about` /\n`Arg::help` or `Command::about` / `Arg::help` and `Command::long_about` /\n`Arg::long_help`\n\nIn addition, when `verbatim_doc_comment` is not present, `clap` applies some preprocessing, including:\n\n- Strip leading and trailing whitespace from every line, if present.\n\n- Strip leading and trailing blank lines, if present.\n\n- Interpret each group of non-empty lines as a word-wrapped paragraph.\n\n  We replace newlines within paragraphs with spaces to allow the output\n  to be re-wrapped to the terminal width.\n\n- Strip any excess blank lines so that there is exactly one per paragraph break.\n\n- If the first paragraph ends in exactly one period,\n  remove the trailing period (i.e. strip trailing periods but not trailing ellipses).\n\nSometimes you don't want this preprocessing to apply, for example the comment contains\nsome ASCII art or markdown tables, you would need to preserve LFs along with\nblank lines and the leading/trailing whitespace. When you pass use the\n`verbatim_doc_comment` magic attribute, you  preserve\nthem.\n\n**Note:** Keep in mind that `verbatim_doc_comment` will *still*\n- Remove one leading space from each line, even if this attribute is present,\n  to allow for a space between `///` and the content.\n- Remove leading and trailing blank lines\n\n## Mixing Builder and Derive APIs\n\nThe builder and derive APIs do not live in isolation. They can work together, which is\nespecially helpful if some arguments can be specified at compile-time while others must be\nspecified at runtime.\n\n### Using derived arguments in a builder application\n\nWhen using the derive API, you can `#[command(flatten)]` a struct deriving `Args` into a struct\nderiving `Args` or `Parser`. This example shows how you can augment a `Command` instance\ncreated using the builder API with `Args` created using the derive API.\n\nIt uses the [`Args::augment_args`][crate::Args::augment_args] method to add the arguments to\nthe `Command` instance.\n\nCrates such as [clap-verbosity-flag](https://github.com/rust-cli/clap-verbosity-flag) provide\nstructs that implement `Args`. Without the technique shown in this example, it would not be\npossible to use such crates with the builder API.\n\nFor example:\n```rust\nuse clap::{arg, Args, Command, FromArgMatches as _};\n\n#[derive(Args, Debug)]\nstruct DerivedArgs {\n    #[arg(short, long)]\n    derived: bool,\n}\n\nfn main() {\n    let cli = Command::new(\"CLI\").arg(arg!(-b - -built).action(clap::ArgAction::SetTrue));\n    // Augment built args with derived args\n    let cli = DerivedArgs::augment_args(cli);\n\n    let matches = cli.get_matches();\n    println!(\"Value of built: {:?}\", matches.get_flag(\"built\"));\n    println!(\n        \"Value of derived via ArgMatches: {:?}\",\n        matches.get_flag(\"derived\")\n    );\n\n    // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.\n    // This is the main benefit of using derived arguments.\n    let derived_matches = DerivedArgs::from_arg_matches(&matches)\n        .map_err(|err| err.exit())\n        .unwrap();\n    println!(\"Value of derived: {derived_matches:#?}\");\n}\n```\n\n### Using derived subcommands in a builder application\n\nWhen using the derive API, you can use `#[command(subcommand)]` inside the struct to add\nsubcommands. The type of the field is usually an enum that derived `Parser`. However, you can\nalso add the subcommands in that enum to a `Command` instance created with the builder API.\n\nIt uses the [`Subcommand::augment_subcommands`][crate::Subcommand::augment_subcommands] method\nto add the subcommands to the `Command` instance.\n\nFor example:\n```rust\nuse clap::{Command, FromArgMatches as _, Parser, Subcommand as _};\n\n#[derive(Parser, Debug)]\nenum Subcommands {\n    Derived {\n        #[arg(short, long)]\n        derived_flag: bool,\n    },\n}\n\nfn main() {\n    let cli = Command::new(\"Built CLI\");\n    // Augment with derived subcommands\n    let cli = Subcommands::augment_subcommands(cli);\n\n    let matches = cli.get_matches();\n    let derived_subcommands = Subcommands::from_arg_matches(&matches)\n        .map_err(|err| err.exit())\n        .unwrap();\n    println!(\"Derived subcommands: {derived_subcommands:#?}\");\n}\n```\n\n### Adding hand-implemented subcommands to a derived application\n\nWhen using the derive API, you can use `#[command(subcommand)]` inside the struct to add\nsubcommands. The type of the field is usually an enum that derived `Parser`. However, you can\nalso implement the `Subcommand` trait manually on this enum (or any other type) and it can\nstill be used inside the struct created with the derive API. The implementation of the\n`Subcommand` trait will use the builder API to add the subcommands to the `Command` instance\ncreated behind the scenes for you by the derive API.\n\nNotice how in the previous example we used\n[`augment_subcommands`][crate::Subcommand::augment_subcommands] on an enum that derived\n`Parser`, whereas now we implement\n[`augment_subcommands`][crate::Subcommand::augment_subcommands] ourselves, but the derive API\ncalls it automatically since we used the `#[command(subcommand)]` attribute.\n\nFor example:\n```rust\n#![allow(dead_code)]\nuse clap::error::{Error, ErrorKind};\nuse clap::{ArgMatches, Args as _, Command, FromArgMatches, Parser, Subcommand};\n\n#[derive(Parser, Debug)]\nstruct AddArgs {\n    name: Vec<String>,\n}\n#[derive(Parser, Debug)]\nstruct RemoveArgs {\n    #[arg(short, long)]\n    force: bool,\n    name: Vec<String>,\n}\n\n#[derive(Debug)]\nenum CliSub {\n    Add(AddArgs),\n    Remove(RemoveArgs),\n}\n\nimpl FromArgMatches for CliSub {\n    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {\n        match matches.subcommand() {\n            Some((\"add\", args)) => Ok(Self::Add(AddArgs::from_arg_matches(args)?)),\n            Some((\"remove\", args)) => Ok(Self::Remove(RemoveArgs::from_arg_matches(args)?)),\n            Some((_, _)) => Err(Error::raw(\n                ErrorKind::InvalidSubcommand,\n                \"Valid subcommands are `add` and `remove`\",\n            )),\n            None => Err(Error::raw(\n                ErrorKind::MissingSubcommand,\n                \"Valid subcommands are `add` and `remove`\",\n            )),\n        }\n    }\n    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {\n        match matches.subcommand() {\n            Some((\"add\", args)) => *self = Self::Add(AddArgs::from_arg_matches(args)?),\n            Some((\"remove\", args)) => *self = Self::Remove(RemoveArgs::from_arg_matches(args)?),\n            Some((_, _)) => {\n                return Err(Error::raw(\n                    ErrorKind::InvalidSubcommand,\n                    \"Valid subcommands are `add` and `remove`\",\n                ))\n            }\n            None => (),\n        };\n        Ok(())\n    }\n}\n\nimpl Subcommand for CliSub {\n    fn augment_subcommands(cmd: Command) -> Command {\n        cmd.subcommand(AddArgs::augment_args(Command::new(\"add\")))\n            .subcommand(RemoveArgs::augment_args(Command::new(\"remove\")))\n            .subcommand_required(true)\n    }\n    fn augment_subcommands_for_update(cmd: Command) -> Command {\n        cmd.subcommand(AddArgs::augment_args(Command::new(\"add\")))\n            .subcommand(RemoveArgs::augment_args(Command::new(\"remove\")))\n            .subcommand_required(true)\n    }\n    fn has_subcommand(name: &str) -> bool {\n        matches!(name, \"add\" | \"remove\")\n    }\n}\n\n#[derive(Parser, Debug)]\nstruct Cli {\n    #[arg(short, long)]\n    top_level: bool,\n    #[command(subcommand)]\n    subcommand: CliSub,\n}\n\nfn main() {\n    let args = Cli::parse();\n    println!(\"{args:#?}\");\n}\n```\n\n### Flattening hand-implemented args into a derived application\n\nWhen using the derive API, you can use `#[command(flatten)]` inside the struct to add arguments as\nif they were added directly to the containing struct. The type of the field is usually an\nstruct that derived `Args`. However, you can also implement the `Args` trait manually on this\nstruct (or any other type) and it can still be used inside the struct created with the derive\nAPI. The implementation of the `Args` trait will use the builder API to add the arguments to\nthe `Command` instance created behind the scenes for you by the derive API.\n\nNotice how in the previous example we used [`augment_args`][crate::Args::augment_args] on the\nstruct that derived `Parser`, whereas now we implement\n[`augment_args`][crate::Args::augment_args] ourselves, but the derive API calls it\nautomatically since we used the `#[command(flatten)]` attribute.\n\nFor example:\n```rust\nuse clap::error::Error;\nuse clap::{Arg, ArgAction, ArgMatches, Args, Command, FromArgMatches, Parser};\n\n#[derive(Debug)]\nstruct CliArgs {\n    foo: bool,\n    bar: bool,\n    quuz: Option<String>,\n}\n\nimpl FromArgMatches for CliArgs {\n    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {\n        let mut matches = matches.clone();\n        Self::from_arg_matches_mut(&mut matches)\n    }\n    fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {\n        Ok(Self {\n            foo: matches.get_flag(\"foo\"),\n            bar: matches.get_flag(\"bar\"),\n            quuz: matches.remove_one::<String>(\"quuz\"),\n        })\n    }\n    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {\n        let mut matches = matches.clone();\n        self.update_from_arg_matches_mut(&mut matches)\n    }\n    fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {\n        self.foo |= matches.get_flag(\"foo\");\n        self.bar |= matches.get_flag(\"bar\");\n        if let Some(quuz) = matches.remove_one::<String>(\"quuz\") {\n            self.quuz = Some(quuz);\n        }\n        Ok(())\n    }\n}\n\nimpl Args for CliArgs {\n    fn augment_args(cmd: Command) -> Command {\n        cmd.arg(\n            Arg::new(\"foo\")\n                .short('f')\n                .long(\"foo\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"bar\")\n                .short('b')\n                .long(\"bar\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"quuz\")\n                .short('q')\n                .long(\"quuz\")\n                .action(ArgAction::Set),\n        )\n    }\n    fn augment_args_for_update(cmd: Command) -> Command {\n        cmd.arg(\n            Arg::new(\"foo\")\n                .short('f')\n                .long(\"foo\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"bar\")\n                .short('b')\n                .long(\"bar\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"quuz\")\n                .short('q')\n                .long(\"quuz\")\n                .action(ArgAction::Set),\n        )\n    }\n}\n\n#[derive(Parser, Debug)]\nstruct Cli {\n    #[arg(short, long)]\n    top_level: bool,\n    #[command(flatten)]\n    more_args: CliArgs,\n}\n\nfn main() {\n    let args = Cli::parse();\n    println!(\"{args:#?}\");\n}\n```\n\n## Tips\n\n- To get access to a [`Command`][crate::Command] call\n  [`CommandFactory::command`][crate::CommandFactory::command] (implemented when deriving\n  [`Parser`][crate::Parser])\n- Proactively check for bad [`Command`][crate::Command] configurations by calling\n  [`Command::debug_assert`][crate::Command::debug_assert] in a test\n  ([example][_tutorial#testing])\n- Always remember to [document](#doc-comments) args and commands with `#![deny(missing_docs)]`"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/cargo_example_derive.rs",
      "content": "# Example: cargo subcommand (Derive API)\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)] // requires `derive` feature\n#[command(name = \"cargo\")]\n#[command(bin_name = \"cargo\")]\n#[command(styles = CLAP_STYLING)]\nenum CargoCli {\n    ExampleDerive(ExampleDeriveArgs),\n}\n\n// See also `clap_cargo::style::CLAP_STYLING`\npub const CLAP_STYLING: clap::builder::styling::Styles = clap::builder::styling::Styles::styled()\n    .header(clap_cargo::style::HEADER)\n    .usage(clap_cargo::style::USAGE)\n    .literal(clap_cargo::style::LITERAL)\n    .placeholder(clap_cargo::style::PLACEHOLDER)\n    .error(clap_cargo::style::ERROR)\n    .valid(clap_cargo::style::VALID)\n    .invalid(clap_cargo::style::INVALID);\n\n#[derive(clap::Args)]\n#[command(version, about, long_about = None)]\nstruct ExampleDeriveArgs {\n    #[arg(long)]\n    manifest_path: Option<std::path::PathBuf>,\n}\n\nfn main() {\n    let CargoCli::ExampleDerive(args) = CargoCli::parse();\n    println!(\"{:?}\", args.manifest_path);\n}\n```\n\nFor more on creating a custom subcommand, see [the cargo\nbook](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).\nThe crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in\nmimicking cargo's interface.\n\nThe help looks like:\n```console\n$ cargo-example-derive --help\nUsage: cargo <COMMAND>\n\nCommands:\n  example-derive  A simple to use, efficient, and full-featured Command Line Argument Parser\n  help            Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ cargo-example-derive example-derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: cargo example-derive [OPTIONS]\n\nOptions:\n      --manifest-path <MANIFEST_PATH>  \n  -h, --help                           Print help\n  -V, --version                        Print version\n\n```\n\nThen to directly invoke the command, run:\n```console\n$ cargo-example-derive example-derive\nNone\n\n$ cargo-example-derive example-derive --manifest-path Cargo.toml\nSome(\"Cargo.toml\")\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/repl.rs",
      "content": "# Example: Command REPL (Builder API)\n\n```rust\nuse std::io::Write;\n\nuse clap::Command;\n\nfn main() -> Result<(), String> {\n    loop {\n        let line = readline()?;\n        let line = line.trim();\n        if line.is_empty() {\n            continue;\n        }\n\n        match respond(line) {\n            Ok(quit) => {\n                if quit {\n                    break;\n                }\n            }\n            Err(err) => {\n                write!(std::io::stdout(), \"{err}\").map_err(|e| e.to_string())?;\n                std::io::stdout().flush().map_err(|e| e.to_string())?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn respond(line: &str) -> Result<bool, String> {\n    let args = shlex::split(line).ok_or(\"error: Invalid quoting\")?;\n    let matches = cli()\n        .try_get_matches_from(args)\n        .map_err(|e| e.to_string())?;\n    match matches.subcommand() {\n        Some((\"ping\", _matches)) => {\n            write!(std::io::stdout(), \"Pong\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n        }\n        Some((\"quit\", _matches)) => {\n            write!(std::io::stdout(), \"Exiting ...\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n            return Ok(true);\n        }\n        Some((name, _matches)) => unimplemented!(\"{name}\"),\n        None => unreachable!(\"subcommand required\"),\n    }\n\n    Ok(false)\n}\n\nfn cli() -> Command {\n    // strip out usage\n    const PARSER_TEMPLATE: &str = \"\\\n        {all-args}\n    \";\n    // strip out name/version\n    const APPLET_TEMPLATE: &str = \"\\\n        {about-with-newline}\\n\\\n        {usage-heading}\\n    {usage}\\n\\\n        \\n\\\n        {all-args}{after-help}\\\n    \";\n\n    Command::new(\"repl\")\n        .multicall(true)\n        .arg_required_else_help(true)\n        .subcommand_required(true)\n        .subcommand_value_name(\"APPLET\")\n        .subcommand_help_heading(\"APPLETS\")\n        .help_template(PARSER_TEMPLATE)\n        .subcommand(\n            Command::new(\"ping\")\n                .about(\"Get a response\")\n                .help_template(APPLET_TEMPLATE),\n        )\n        .subcommand(\n            Command::new(\"quit\")\n                .alias(\"exit\")\n                .about(\"Quit the REPL\")\n                .help_template(APPLET_TEMPLATE),\n        )\n}\n\nfn readline() -> Result<String, String> {\n    write!(std::io::stdout(), \"$ \").map_err(|e| e.to_string())?;\n    std::io::stdout().flush().map_err(|e| e.to_string())?;\n    let mut buffer = String::new();\n    std::io::stdin()\n        .read_line(&mut buffer)\n        .map_err(|e| e.to_string())?;\n    Ok(buffer)\n}\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/lib.rs",
      "content": "> **Command Line Argument Parser for Rust**\n\nQuick Links:\n- Derive [tutorial][_derive::_tutorial] and [reference][_derive]\n- Builder [tutorial][_tutorial] and [reference][Command]\n- [Cookbook][_cookbook]\n- [FAQ][_faq]\n- [Discussions](https://github.com/clap-rs/clap/discussions)\n- [CHANGELOG](https://github.com/clap-rs/clap/blob/v4.5.39/CHANGELOG.md) (includes major version migration\n  guides)\n\n## Aspirations\n\n- Out of the box, users get a polished CLI experience\n  - Including common argument behavior, help generation, suggested fixes for users, colored output, [shell completions](https://github.com/clap-rs/clap/tree/master/clap_complete), etc\n- Flexible enough to port your existing CLI interface\n  - However, we won't necessarily streamline support for each use case\n- Reasonable parse performance\n- Resilient maintainership, including\n  - Willing to break compatibility rather than batching up breaking changes in large releases\n  - Leverage feature flags to keep to one active branch\n  - Being under [WG-CLI](https://github.com/rust-cli/team/) to increase the bus factor\n- We follow semver and will wait about 6-9 months between major breaking changes\n- We will support the last two minor Rust releases (MSRV, currently 1.74)\n\nWhile these aspirations can be at odds with fast build times and low binary\nsize, we will still strive to keep these reasonable for the flexibility you\nget.  Check out the\n[argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs) for\nCLI parsers optimized for other use cases.\n\n## Example\n\nRun\n```console\n$ cargo add clap --features derive\n```\n*(See also [feature flag reference][_features])*\n\nThen define your CLI in `main.rs`:\n```rust\n# #[cfg(feature = \"derive\")] {\nuse clap::Parser;\n\n/// Simple program to greet a person\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    /// Name of the person to greet\n    #[arg(short, long)]\n    name: String,\n\n    /// Number of times to greet\n    #[arg(short, long, default_value_t = 1)]\n    count: u8,\n}\n\nfn main() {\n    let args = Args::parse();\n\n    for _ in 0..args.count {\n        println!(\"Hello {}!\", args.name);\n    }\n}\n# }\n```\n\nAnd try it out:\n```console\n$ demo --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: demo[EXE] [OPTIONS] --name <NAME>\n\nOptions:\n  -n, --name <NAME>    Name of the person to greet\n  -c, --count <COUNT>  Number of times to greet [default: 1]\n  -h, --help           Print help\n  -V, --version        Print version\n\n$ demo --name Me\nHello Me!\n\n```\n*(version number and `.exe` extension on windows replaced by placeholders)*\n\nSee also the derive [tutorial][_derive::_tutorial] and [reference][_derive]\n\n### Related Projects\n\nAugment clap:\n- [wild](https://crates.io/crates/wild) for supporting wildcards (`*`) on Windows like you do Linux\n- [argfile](https://crates.io/crates/argfile) for loading additional arguments from a file (aka response files)\n- [shadow-rs](https://crates.io/crates/shadow-rs) for generating `Command::long_version`\n- [clap_mangen](https://crates.io/crates/clap_mangen) for generating man page source (roff)\n- [clap_complete](https://crates.io/crates/clap_complete) for shell completion support\n\nCLI Helpers\n- [clio](https://crates.io/crates/clio) for reading/writing to files specified as arguments\n- [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)\n- [clap-cargo](https://crates.io/crates/clap-cargo)\n- [colorchoice-clap](https://crates.io/crates/colorchoice-clap)\n\nTesting\n- [`trycmd`](https://crates.io/crates/trycmd):  Bulk snapshot testing\n- [`snapbox`](https://crates.io/crates/snapbox):  Specialized snapshot testing\n- [`assert_cmd`](https://crates.io/crates/assert_cmd) and [`assert_fs`](https://crates.io/crates/assert_fs): Customized testing\n\nDocumentation:\n- [Command-line Apps for Rust](https://rust-cli.github.io/book/index.html) book\n"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/git_derive.rs",
      "content": "# Example: git-like CLI (Derive API)\n\n```rust\nuse std::ffi::OsStr;\nuse std::ffi::OsString;\nuse std::path::PathBuf;\n\nuse clap::{Args, Parser, Subcommand, ValueEnum};\n\n/// A fictional versioning CLI\n#[derive(Debug, Parser)] // requires `derive` feature\n#[command(name = \"git\")]\n#[command(about = \"A fictional versioning CLI\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Clones repos\n    #[command(arg_required_else_help = true)]\n    Clone {\n        /// The remote to clone\n        remote: String,\n    },\n    /// Compare two commits\n    Diff {\n        #[arg(value_name = \"COMMIT\")]\n        base: Option<OsString>,\n        #[arg(value_name = \"COMMIT\")]\n        head: Option<OsString>,\n        #[arg(last = true)]\n        path: Option<OsString>,\n        #[arg(\n            long,\n            require_equals = true,\n            value_name = \"WHEN\",\n            num_args = 0..=1,\n            default_value_t = ColorWhen::Auto,\n            default_missing_value = \"always\",\n            value_enum\n        )]\n        color: ColorWhen,\n    },\n    /// pushes things\n    #[command(arg_required_else_help = true)]\n    Push {\n        /// The remote to target\n        remote: String,\n    },\n    /// adds things\n    #[command(arg_required_else_help = true)]\n    Add {\n        /// Stuff to add\n        #[arg(required = true)]\n        path: Vec<PathBuf>,\n    },\n    Stash(StashArgs),\n    #[command(external_subcommand)]\n    External(Vec<OsString>),\n}\n\n#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]\nenum ColorWhen {\n    Always,\n    Auto,\n    Never,\n}\n\nimpl std::fmt::Display for ColorWhen {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.to_possible_value()\n            .expect(\"no values are skipped\")\n            .get_name()\n            .fmt(f)\n    }\n}\n\n#[derive(Debug, Args)]\n#[command(args_conflicts_with_subcommands = true)]\n#[command(flatten_help = true)]\nstruct StashArgs {\n    #[command(subcommand)]\n    command: Option<StashCommands>,\n\n    #[command(flatten)]\n    push: StashPushArgs,\n}\n\n#[derive(Debug, Subcommand)]\nenum StashCommands {\n    Push(StashPushArgs),\n    Pop { stash: Option<String> },\n    Apply { stash: Option<String> },\n}\n\n#[derive(Debug, Args)]\nstruct StashPushArgs {\n    #[arg(short, long)]\n    message: Option<String>,\n}\n\nfn main() {\n    let args = Cli::parse();\n\n    match args.command {\n        Commands::Clone { remote } => {\n            println!(\"Cloning {remote}\");\n        }\n        Commands::Diff {\n            mut base,\n            mut head,\n            mut path,\n            color,\n        } => {\n            if path.is_none() {\n                path = head;\n                head = None;\n                if path.is_none() {\n                    path = base;\n                    base = None;\n                }\n            }\n            let base = base\n                .as_deref()\n                .map(|s| s.to_str().unwrap())\n                .unwrap_or(\"stage\");\n            let head = head\n                .as_deref()\n                .map(|s| s.to_str().unwrap())\n                .unwrap_or(\"worktree\");\n            let path = path.as_deref().unwrap_or_else(|| OsStr::new(\"\"));\n            println!(\n                \"Diffing {}..{} {} (color={})\",\n                base,\n                head,\n                path.to_string_lossy(),\n                color\n            );\n        }\n        Commands::Push { remote } => {\n            println!(\"Pushing to {remote}\");\n        }\n        Commands::Add { path } => {\n            println!(\"Adding {path:?}\");\n        }\n        Commands::Stash(stash) => {\n            let stash_cmd = stash.command.unwrap_or(StashCommands::Push(stash.push));\n            match stash_cmd {\n                StashCommands::Push(push) => {\n                    println!(\"Pushing {push:?}\");\n                }\n                StashCommands::Pop { stash } => {\n                    println!(\"Popping {stash:?}\");\n                }\n                StashCommands::Apply { stash } => {\n                    println!(\"Applying {stash:?}\");\n                }\n            }\n        }\n        Commands::External(args) => {\n            println!(\"Calling out to {:?} with {:?}\", &args[0], &args[1..]);\n        }\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nGit is an example of several common subcommand patterns.\n\nHelp:\n```console\n$ git-derive\n? failed\nA fictional versioning CLI\n\nUsage: git-derive[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive help\nA fictional versioning CLI\n\nUsage: git-derive[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive help add\nadds things\n\nUsage: git-derive[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n```\n\nA basic argument:\n```console\n$ git-derive add\n? failed\nadds things\n\nUsage: git-derive[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive add Cargo.toml Cargo.lock\nAdding [\"Cargo.toml\", \"Cargo.lock\"]\n\n```\n\nDefault subcommand:\n```console\n$ git-derive stash -h\nUsage: git-derive[EXE] stash [OPTIONS]\n       git-derive[EXE] stash push [OPTIONS]\n       git-derive[EXE] stash pop [STASH]\n       git-derive[EXE] stash apply [STASH]\n       git-derive[EXE] stash help [COMMAND]...\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\ngit-derive[EXE] stash push:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\ngit-derive[EXE] stash pop:\n  -h, --help  Print help\n  [STASH]     \n\ngit-derive[EXE] stash apply:\n  -h, --help  Print help\n  [STASH]     \n\ngit-derive[EXE] stash help:\nPrint this message or the help of the given subcommand(s)\n  [COMMAND]...  Print help for the subcommand(s)\n\n$ git-derive stash push -h\nUsage: git-derive[EXE] stash push [OPTIONS]\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git-derive stash pop -h\nUsage: git-derive[EXE] stash pop [STASH]\n\nArguments:\n  [STASH]  \n\nOptions:\n  -h, --help  Print help\n\n$ git-derive stash -m \"Prototype\"\nPushing StashPushArgs { message: Some(\"Prototype\") }\n\n$ git-derive stash pop\nPopping None\n\n$ git-derive stash push -m \"Prototype\"\nPushing StashPushArgs { message: Some(\"Prototype\") }\n\n$ git-derive stash pop\nPopping None\n\n```\n\nExternal subcommands:\n```console\n$ git-derive custom-tool arg1 --foo bar\nCalling out to \"custom-tool\" with [\"arg1\", \"--foo\", \"bar\"]\n\n```\n\nLast argument:\n```console\n$ git-derive diff --help\nCompare two commits\n\nUsage: git-derive[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]\n\nArguments:\n  [COMMIT]  \n  [COMMIT]  \n  [PATH]    \n\nOptions:\n      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]\n  -h, --help            Print help\n\n$ git-derive diff\nDiffing stage..worktree  (color=auto)\n\n$ git-derive diff ./src\nDiffing stage..worktree ./src (color=auto)\n\n$ git-derive diff HEAD ./src\nDiffing HEAD..worktree ./src (color=auto)\n\n$ git-derive diff HEAD~~ -- HEAD\nDiffing HEAD~~..worktree HEAD (color=auto)\n\n$ git-derive diff --color\nDiffing stage..worktree  (color=always)\n\n$ git-derive diff --color=never\nDiffing stage..worktree  (color=never)\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/multicall_hostname.rs",
      "content": "# Example: hostname-like CLI (Builder API)\n\n```rust\nuse clap::Command;\n\nfn main() {\n    let cmd = Command::new(env!(\"CARGO_CRATE_NAME\"))\n        .multicall(true)\n        .arg_required_else_help(true)\n        .subcommand_value_name(\"APPLET\")\n        .subcommand_help_heading(\"APPLETS\")\n        .subcommand(Command::new(\"hostname\").about(\"show hostname part of FQDN\"))\n        .subcommand(Command::new(\"dnsdomainname\").about(\"show domain name part of FQDN\"));\n\n    match cmd.get_matches().subcommand_name() {\n        Some(\"hostname\") => println!(\"www\"),\n        Some(\"dnsdomainname\") => println!(\"example.com\"),\n        _ => unreachable!(\"parser should ensure only valid subcommand names are used\"),\n    }\n}\n```\n\nSee the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.\n\nThis example omits the implementation of displaying address config\n\n```console\n$ hostname\nwww\n\n```\n*Note: without the links setup, we can't demonstrate the multicall behavior*"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_tutorial.rs",
      "content": "## Tutorial for the Builder API\n\n*See the side bar for the Table of Contents*\n\n## Quick Start\n\nYou can create an application with several arguments using usage strings.\n\nFirst, ensure `clap` is available:\n```console\n$ cargo add clap\n```\n\nHere is a preview of the type of application you can make:\n```rust\nuse std::path::PathBuf;\n\nuse clap::{arg, command, value_parser, ArgAction, Command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(arg!([name] \"Optional name to operate on\"))\n        .arg(\n            arg!(\n                -c --config <FILE> \"Sets a custom config file\"\n            )\n            // We don't have syntax yet for optional options, so manually calling `required`\n            .required(false)\n            .value_parser(value_parser!(PathBuf)),\n        )\n        .arg(arg!(\n            -d --debug ... \"Turn debugging information on\"\n        ))\n        .subcommand(\n            Command::new(\"test\")\n                .about(\"does testing things\")\n                .arg(arg!(-l --list \"lists test values\").action(ArgAction::SetTrue)),\n        )\n        .get_matches();\n\n    // You can check the value provided by positional arguments, or option arguments\n    if let Some(name) = matches.get_one::<String>(\"name\") {\n        println!(\"Value for name: {name}\");\n    }\n\n    if let Some(config_path) = matches.get_one::<PathBuf>(\"config\") {\n        println!(\"Value for config: {}\", config_path.display());\n    }\n\n    // You can see how many times a particular flag or argument occurred\n    // Note, only flags can have multiple occurrences\n    match matches\n        .get_one::<u8>(\"debug\")\n        .expect(\"Counts are defaulted\")\n    {\n        0 => println!(\"Debug mode is off\"),\n        1 => println!(\"Debug mode is kind of on\"),\n        2 => println!(\"Debug mode is on\"),\n        _ => println!(\"Don't be crazy\"),\n    }\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    if let Some(matches) = matches.subcommand_matches(\"test\") {\n        // \"$ myapp test\" was run\n        if matches.get_flag(\"list\") {\n            // \"$ myapp test -l\" was run\n            println!(\"Printing testing lists...\");\n        } else {\n            println!(\"Not printing testing lists...\");\n        }\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n```console\n$ 01_quick --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 01_quick[EXE] [OPTIONS] [name] [COMMAND]\n\nCommands:\n  test  does testing things\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  [name]  Optional name to operate on\n\nOptions:\n  -c, --config <FILE>  Sets a custom config file\n  -d, --debug...       Turn debugging information on\n  -h, --help           Print help\n  -V, --version        Print version\n\n```\n\nBy default, the program does nothing:\n```console\n$ 01_quick\nDebug mode is off\n\n```\n\nBut you can mix and match the various features\n```console\n$ 01_quick -dd test\nDebug mode is on\nNot printing testing lists...\n\n```\n\nSee also\n- [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]\n- The [cookbook][crate::_cookbook] for more application-focused examples\n\n## Configuring the Parser\n\nYou use [`Command`][crate::Command] to start building a parser.\n\n```rust\nuse clap::{arg, Command};\n\nfn main() {\n    let matches = Command::new(\"MyApp\")\n        .version(\"1.0\")\n        .about(\"Does awesome things\")\n        .arg(arg!(--two <VALUE>).required(true))\n        .arg(arg!(--one <VALUE>).required(true))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n\n```console\n$ 02_apps --help\nDoes awesome things\n\nUsage: 02_apps[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>  \n      --one <VALUE>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 02_apps --version\nMyApp 1.0\n\n```\n\nYou can use [`command!()`][crate::command!] to fill these fields in from your `Cargo.toml`\nfile.  **This requires the [`cargo` feature flag][crate::_features].**\n\n```rust\nuse clap::{arg, command};\n\nfn main() {\n    // requires `cargo` feature, reading name, version, author, and description from `Cargo.toml`\n    let matches = command!()\n        .arg(arg!(--two <VALUE>).required(true))\n        .arg(arg!(--one <VALUE>).required(true))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n```console\n$ 02_crate --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_crate[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>  \n      --one <VALUE>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 02_crate --version\nclap [..]\n\n```\n\nYou can use [`Command`][crate::Command] methods to change the application level behavior of\nclap, like [`Command::next_line_help`].\n\n```rust\nuse clap::{arg, command, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .next_line_help(true)\n        .arg(arg!(--two <VALUE>).required(true).action(ArgAction::Set))\n        .arg(arg!(--one <VALUE>).required(true).action(ArgAction::Set))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n```console\n$ 02_app_settings --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_app_settings[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>\n          \n      --one <VALUE>\n          \n  -h, --help\n          Print help\n  -V, --version\n          Print version\n\n```\n\n## Adding Arguments\n\n1. [Positionals](#positionals)\n2. [Options](#options)\n3. [Flags](#flags)\n4. [Required](#required)\n5. [Defaults](#defaults)\n6. [Subcommands](#subcommands)\n\n\n### Positionals\n\nBy default, an [`Arg`] defines a positional argument:\n\n```rust\nuse clap::{command, Arg};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\"))\n        .get_matches();\n\n    println!(\"name: {:?}\", matches.get_one::<String>(\"name\"));\n}\n```\n```console\n$ 03_03_positional --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional[EXE] [name]\n\nArguments:\n  [name]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional\nname: None\n\n$ 03_03_positional bob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple values, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append]:\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\").action(ArgAction::Append))\n        .get_matches();\n\n    let args = matches\n        .get_many::<String>(\"name\")\n        .unwrap_or_default()\n        .map(|v| v.as_str())\n        .collect::<Vec<_>>();\n\n    println!(\"names: {:?}\", &args);\n}\n```\n```console\n$ 03_03_positional_mult --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_mult[EXE] [name]...\n\nArguments:\n  [name]...  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_mult\nnames: []\n\n$ 03_03_positional_mult bob\nnames: [\"bob\"]\n\n$ 03_03_positional_mult bob john\nnames: [\"bob\", \"john\"]\n\n```\n\n### Options\n\nYou can name your arguments with a flag:\n- Intent of the value is clearer\n- Order doesn't matter\n\n```rust\nuse clap::{command, Arg};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\").short('n').long(\"name\"))\n        .get_matches();\n\n    println!(\"name: {:?}\", matches.get_one::<String>(\"name\"));\n}\n```\n```console\n$ 03_02_option --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <name>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option\nname: None\n\n$ 03_02_option --name bob\nname: Some(\"bob\")\n\n$ 03_02_option --name=bob\nname: Some(\"bob\")\n\n$ 03_02_option -n bob\nname: Some(\"bob\")\n\n$ 03_02_option -n=bob\nname: Some(\"bob\")\n\n$ 03_02_option -nbob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple occurrences, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append]:\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"name\")\n                .short('n')\n                .long(\"name\")\n                .action(ArgAction::Append),\n        )\n        .get_matches();\n\n    let args = matches\n        .get_many::<String>(\"name\")\n        .unwrap_or_default()\n        .map(|v| v.as_str())\n        .collect::<Vec<_>>();\n\n    println!(\"names: {:?}\", &args);\n}\n```\n```console\n$ 03_02_option_mult --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_mult[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <name>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_mult\nnames: []\n\n$ 03_02_option_mult --name bob\nnames: [\"bob\"]\n\n$ 03_02_option_mult --name bob --name john\nnames: [\"bob\", \"john\"]\n\n$ 03_02_option_mult_derive --name bob --name=john -n tom -n=chris -nsteve\nname: [\"bob\", \"john\", \"tom\", \"chris\", \"steve\"]\n\n```\n\n### Flags\n\nFlags can also be switches that can be on/off:\n\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .action(ArgAction::SetTrue),\n        )\n        .get_matches();\n\n    println!(\"verbose: {:?}\", matches.get_flag(\"verbose\"));\n}\n```\n```console\n$ 03_01_flag_bool --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_bool[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose  \n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_01_flag_bool\nverbose: false\n\n$ 03_01_flag_bool --verbose\nverbose: true\n\n$ 03_01_flag_bool --verbose --verbose\n? failed\nerror: the argument '--verbose' cannot be used multiple times\n\nUsage: 03_01_flag_bool[EXE] [OPTIONS]\n\nFor more information, try '--help'.\n\n```\n\nTo accept multiple flags, use [`Count`][crate::ArgAction::Count]:\n\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .action(ArgAction::Count),\n        )\n        .get_matches();\n\n    println!(\"verbose: {:?}\", matches.get_count(\"verbose\"));\n}\n```\n```console\n$ 03_01_flag_count --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_count[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose...  \n  -h, --help        Print help\n  -V, --version     Print version\n\n$ 03_01_flag_count\nverbose: 0\n\n$ 03_01_flag_count --verbose\nverbose: 1\n\n$ 03_01_flag_count --verbose --verbose\nverbose: 2\n\n```\n\n### Required\n\nBy default, an [`Arg`] is optional which can be changed with\n[`required`][crate::Arg::required].\n```rust\nuse clap::{command, Arg};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\").required(true))\n        .get_matches();\n\n    println!(\n        \"name: {:?}\",\n        matches\n            .get_one::<String>(\"name\")\n            .expect(\"clap `required` ensures its present\")\n    );\n}\n```\n```console\n$ 03_06_required --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_06_required[EXE] <name>\n\nArguments:\n  <name>  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_06_required\n? 2\nerror: the following required arguments were not provided:\n  <name>\n\nUsage: 03_06_required[EXE] <name>\n\nFor more information, try '--help'.\n\n$ 03_06_required bob\nname: \"bob\"\n\n```\n\n### Defaults\n\nWe've previously showed that arguments can be [`required`][crate::Arg::required] or optional.\nWhen optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can set\n[`Arg::default_value`][crate::Arg::default_value].\n\n```rust\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!([PORT])\n                .value_parser(value_parser!(u16))\n                .default_value(\"2020\"),\n        )\n        .get_matches();\n\n    println!(\n        \"port: {:?}\",\n        matches\n            .get_one::<u16>(\"PORT\")\n            .expect(\"default ensures there is always a value\")\n    );\n}\n```\n```console\n$ 03_05_default_values --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_05_default_values[EXE] [PORT]\n\nArguments:\n  [PORT]  [default: 2020]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_05_default_values\nport: 2020\n\n$ 03_05_default_values 22\nport: 22\n\n```\n\n### Subcommands\n\nSubcommands are defined as [`Command`][crate::Command]s that get added via\n[`Command::subcommand`][crate::Command::subcommand]. Each instance of a Subcommand can have its\nown version, author(s), Args, and even its own subcommands.\n\n```rust\nuse clap::{arg, command, Command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .propagate_version(true)\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        .subcommand(\n            Command::new(\"add\")\n                .about(\"Adds files to myapp\")\n                .arg(arg!([NAME])),\n        )\n        .get_matches();\n\n    match matches.subcommand() {\n        Some((\"add\", sub_matches)) => println!(\n            \"'myapp add' was used, name is: {:?}\",\n            sub_matches.get_one::<String>(\"NAME\")\n        ),\n        _ => unreachable!(\"Exhausted list of subcommands and subcommand_required prevents `None`\"),\n    }\n}\n```\n```console\n$ 03_04_subcommands help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands help add\nAdds files to myapp\n\nUsage: 03_04_subcommands[EXE] add [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands add bob\n'myapp add' was used, name is: Some(\"bob\")\n\n```\n\nWe set\n[`Command::arg_required_else_help`][crate::Command::arg_required_else_help] to\nshow the help, rather than an error, when the\n[required subcommand][crate::Command::subcommand_required] is missing:\n```console\n$ 03_04_subcommands\n? failed\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nSince we specified [`Command::propagate_version`][crate::Command::propagate_version], the `--version` flag\nis available in all subcommands:\n```console\n$ 03_04_subcommands --version\nclap [..]\n\n$ 03_04_subcommands add --version\nclap-add [..]\n\n```\n\n## Validation\n\n1. [Enumerated values](#enumerated-values)\n2. [Validated values](#validated-values)\n3. [Argument Relations](#argument-relations)\n4. [Custom Validation](#custom-validation)\n\nAn appropriate default parser/validator will be selected for the field's type.  See\n[`value_parser!`][crate::value_parser!] for more details.\n\n### Enumerated values\n\nIf you have arguments of specific values you want to test for, you can use the\n[`PossibleValuesParser`][crate::builder::PossibleValuesParser] or [`Arg::value_parser([\"val1\",\n...])`][crate::Arg::value_parser] for short.\n\nThis allows you to specify the valid values for that argument. If the user does not use one of\nthose specific values, they will receive a graceful exit with error message informing them\nof the mistake, and what the possible valid values are\n\n```rust\nuse clap::{arg, command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<MODE>)\n                .help(\"What mode to run the program in\")\n                .value_parser([\"fast\", \"slow\"]),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    match matches\n        .get_one::<String>(\"MODE\")\n        .expect(\"'MODE' is required and parsing will fail if its missing\")\n        .as_str()\n    {\n        \"fast\" => {\n            println!(\"Hare\");\n        }\n        \"slow\" => {\n            println!(\"Tortoise\");\n        }\n        _ => unreachable!(),\n    }\n}\n```\n```console\n$ 04_01_possible --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_possible[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_01_possible fast\nHare\n\n$ 04_01_possible slow\nTortoise\n\n$ 04_01_possible medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\nWhen enabling the [`derive` feature][crate::_features], you can use\n[`ValueEnum`][crate::ValueEnum] to take care of the boiler plate for you, giving the same\nresults.\n\n```rust\nuse clap::{arg, builder::PossibleValue, command, value_parser, ValueEnum};\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\nenum Mode {\n    Fast,\n    Slow,\n}\n\n// Can also be derived with feature flag `derive`\nimpl ValueEnum for Mode {\n    fn value_variants<'a>() -> &'a [Self] {\n        &[Mode::Fast, Mode::Slow]\n    }\n\n    fn to_possible_value(&self) -> Option<PossibleValue> {\n        Some(match self {\n            Mode::Fast => PossibleValue::new(\"fast\").help(\"Run swiftly\"),\n            Mode::Slow => PossibleValue::new(\"slow\").help(\"Crawl slowly but steadily\"),\n        })\n    }\n}\n\nimpl std::fmt::Display for Mode {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.to_possible_value()\n            .expect(\"no values are skipped\")\n            .get_name()\n            .fmt(f)\n    }\n}\n\nimpl std::str::FromStr for Mode {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        for variant in Self::value_variants() {\n            if variant.to_possible_value().unwrap().matches(s, false) {\n                return Ok(*variant);\n            }\n        }\n        Err(format!(\"invalid variant: {s}\"))\n    }\n}\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<MODE>)\n                .help(\"What mode to run the program in\")\n                .value_parser(value_parser!(Mode)),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    match matches\n        .get_one::<Mode>(\"MODE\")\n        .expect(\"'MODE' is required and parsing will fail if its missing\")\n    {\n        Mode::Fast => {\n            println!(\"Hare\");\n        }\n        Mode::Slow => {\n            println!(\"Tortoise\");\n        }\n    }\n}\n```\n```console\n$ 04_01_enum --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum[EXE] <MODE>\n\nArguments:\n  <MODE>\n          What mode to run the program in\n\n          Possible values:\n          - fast: Run swiftly\n          - slow: Crawl slowly but steadily\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n$ 04_01_enum -h\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help (see more with '--help')\n  -V, --version  Print version\n\n$ 04_01_enum fast\nHare\n\n$ 04_01_enum slow\nTortoise\n\n$ 04_01_enum medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\n### Validated values\n\nMore generally, you can validate and parse into any data type with [`Arg::value_parser`].\n\n```rust\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(value_parser!(u16).range(1..)),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: u16 = *matches\n        .get_one::<u16>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n```\n```console\n$ 04_02_parse --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_parse[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_parse 22\nPORT = 22\n\n$ 04_02_parse foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': invalid digit found in string\n\nFor more information, try '--help'.\n\n$ 04_02_parse_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': 0 is not in 1..=65535\n\nFor more information, try '--help'.\n\n```\n\nA [custom parser][TypedValueParser] can be used to improve the error messages or provide additional validation:\n\n```rust\nuse std::ops::RangeInclusive;\n\nuse clap::{arg, command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(port_in_range),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: u16 = *matches\n        .get_one::<u16>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n\nconst PORT_RANGE: RangeInclusive<usize> = 1..=65535;\n\nfn port_in_range(s: &str) -> Result<u16, String> {\n    let port: usize = s\n        .parse()\n        .map_err(|_| format!(\"`{s}` isn't a port number\"))?;\n    if PORT_RANGE.contains(&port) {\n        Ok(port as u16)\n    } else {\n        Err(format!(\n            \"port not in range {}-{}\",\n            PORT_RANGE.start(),\n            PORT_RANGE.end()\n        ))\n    }\n}\n```\n```console\n$ 04_02_validate --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_validate[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_validate 22\nPORT = 22\n\n$ 04_02_validate foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number\n\nFor more information, try '--help'.\n\n$ 04_02_validate 0\n? failed\nerror: invalid value '0' for '<PORT>': port not in range 1-65535\n\nFor more information, try '--help'.\n\n```\n\nSee [`Arg::value_parser`][crate::Arg::value_parser] for more details.\n\n### Argument Relations\n\nYou can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even\n[`ArgGroup`][crate::ArgGroup]s.\n\n[`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list\neach individually, or when you want a rule to apply \"any but not all\" arguments.\n\nPerhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one\nargument to be present out of a given set. Imagine that you had multiple arguments, and you\nwant one of them to be required, but making all of them required isn't feasible because perhaps\nthey conflict with each other.\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::{arg, command, value_parser, ArgAction, ArgGroup};\n\nfn main() {\n    // Create application like normal\n    let matches = command!() // requires `cargo` feature\n        // Add the version arguments\n        .arg(arg!(--\"set-ver\" <VER> \"set version manually\"))\n        .arg(arg!(--major         \"auto inc major\").action(ArgAction::SetTrue))\n        .arg(arg!(--minor         \"auto inc minor\").action(ArgAction::SetTrue))\n        .arg(arg!(--patch         \"auto inc patch\").action(ArgAction::SetTrue))\n        // Create a group, make it required, and add the above arguments\n        .group(\n            ArgGroup::new(\"vers\")\n                .required(true)\n                .args([\"set-ver\", \"major\", \"minor\", \"patch\"]),\n        )\n        // Arguments can also be added to a group individually, these two arguments\n        // are part of the \"input\" group which is not required\n        .arg(\n            arg!([INPUT_FILE] \"some regular input\")\n                .value_parser(value_parser!(PathBuf))\n                .group(\"input\"),\n        )\n        .arg(\n            arg!(--\"spec-in\" <SPEC_IN> \"some special input argument\")\n                .value_parser(value_parser!(PathBuf))\n                .group(\"input\"),\n        )\n        // Now let's assume we have a -c [config] argument which requires one of\n        // (but **not** both) the \"input\" arguments\n        .arg(\n            arg!(config: -c <CONFIG>)\n                .value_parser(value_parser!(PathBuf))\n                .requires(\"input\"),\n        )\n        .get_matches();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = matches.get_one::<String>(\"set-ver\") {\n        ver.to_owned()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (\n            matches.get_flag(\"major\"),\n            matches.get_flag(\"minor\"),\n            matches.get_flag(\"patch\"),\n        );\n        match (maj, min, pat) {\n            (true, _, _) => major += 1,\n            (_, true, _) => minor += 1,\n            (_, _, true) => patch += 1,\n            _ => unreachable!(),\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if matches.contains_id(\"config\") {\n        let input = matches\n            .get_one::<PathBuf>(\"INPUT_FILE\")\n            .unwrap_or_else(|| matches.get_one::<PathBuf>(\"spec-in\").unwrap())\n            .display();\n        println!(\n            \"Doing work using input {} and config {}\",\n            input,\n            matches.get_one::<PathBuf>(\"config\").unwrap().display()\n        );\n    }\n}\n```\n```console\n$ 04_03_relations --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_03_relations[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_03_relations\n? failed\nerror: the following required arguments were not provided:\n  <--set-ver <VER>|--major|--minor|--patch>\n\nUsage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major\nVersion: 2.2.3\n\n$ 04_03_relations --major --minor\n? failed\nerror: the argument '--major' cannot be used with '--minor'\n\nUsage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major -c config.toml\n? failed\nerror: the following required arguments were not provided:\n  <INPUT_FILE|--spec-in <SPEC_IN>>\n\nUsage: 04_03_relations[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n### Custom Validation\n\nAs a last resort, you can create custom errors with the basics of clap's formatting.\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::error::ErrorKind;\nuse clap::{arg, command, value_parser, ArgAction};\n\nfn main() {\n    // Create application like normal\n    let mut cmd = command!() // requires `cargo` feature\n        // Add the version arguments\n        .arg(arg!(--\"set-ver\" <VER> \"set version manually\"))\n        .arg(arg!(--major         \"auto inc major\").action(ArgAction::SetTrue))\n        .arg(arg!(--minor         \"auto inc minor\").action(ArgAction::SetTrue))\n        .arg(arg!(--patch         \"auto inc patch\").action(ArgAction::SetTrue))\n        // Arguments can also be added to a group individually, these two arguments\n        // are part of the \"input\" group which is not required\n        .arg(arg!([INPUT_FILE] \"some regular input\").value_parser(value_parser!(PathBuf)))\n        .arg(\n            arg!(--\"spec-in\" <SPEC_IN> \"some special input argument\")\n                .value_parser(value_parser!(PathBuf)),\n        )\n        // Now let's assume we have a -c [config] argument which requires one of\n        // (but **not** both) the \"input\" arguments\n        .arg(arg!(config: -c <CONFIG>).value_parser(value_parser!(PathBuf)));\n    let matches = cmd.get_matches_mut();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = matches.get_one::<String>(\"set-ver\") {\n        if matches.get_flag(\"major\") || matches.get_flag(\"minor\") || matches.get_flag(\"patch\") {\n            cmd.error(\n                ErrorKind::ArgumentConflict,\n                \"Can't do relative and absolute version change\",\n            )\n            .exit();\n        }\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (\n            matches.get_flag(\"major\"),\n            matches.get_flag(\"minor\"),\n            matches.get_flag(\"patch\"),\n        );\n        match (maj, min, pat) {\n            (true, false, false) => major += 1,\n            (false, true, false) => minor += 1,\n            (false, false, true) => patch += 1,\n            _ => {\n                cmd.error(\n                    ErrorKind::ArgumentConflict,\n                    \"Can only modify one version field\",\n                )\n                .exit();\n            }\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if matches.contains_id(\"config\") {\n        let input = matches\n            .get_one::<PathBuf>(\"INPUT_FILE\")\n            .or_else(|| matches.get_one::<PathBuf>(\"spec-in\"))\n            .unwrap_or_else(|| {\n                cmd.error(\n                    ErrorKind::MissingRequiredArgument,\n                    \"INPUT_FILE or --spec-in is required when using --config\",\n                )\n                .exit()\n            })\n            .display();\n        println!(\n            \"Doing work using input {} and config {}\",\n            input,\n            matches.get_one::<PathBuf>(\"config\").unwrap().display()\n        );\n    }\n}\n```\n```console\n$ 04_04_custom --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_04_custom\n? failed\nerror: Can only modify one version field\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major\nVersion: 2.2.3\n\n$ 04_04_custom --major --minor\n? failed\nerror: Can only modify one version field\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major -c config.toml\n? failed\nVersion: 2.2.3\nerror: INPUT_FILE or --spec-in is required when using --config\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n## Testing\n\nclap reports most development errors as `debug_assert!`s.  Rather than checking every\nsubcommand, you should have a test that calls\n[`Command::debug_assert`][crate::Command::debug_assert]:\n```rust,no_run\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = cmd().get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: usize = *matches\n        .get_one::<usize>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n\nfn cmd() -> clap::Command {\n    command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(value_parser!(usize)),\n        )\n}\n\n#[test]\nfn verify_cmd() {\n    cmd().debug_assert();\n}\n```\n\n## Next Steps\n\n- [Cookbook][crate::_cookbook] for application-focused examples\n- Explore more features in the [API reference][super]\n\nFor support, see [Discussions](https://github.com/clap-rs/clap/discussions)"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/git.rs",
      "content": "# Example: git-like CLI (Builder API)\n\n```rust\nuse std::ffi::OsString;\nuse std::path::PathBuf;\n\nuse clap::{arg, Command};\n\nfn cli() -> Command {\n    Command::new(\"git\")\n        .about(\"A fictional versioning CLI\")\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        .allow_external_subcommands(true)\n        .subcommand(\n            Command::new(\"clone\")\n                .about(\"Clones repos\")\n                .arg(arg!(<REMOTE> \"The remote to clone\"))\n                .arg_required_else_help(true),\n        )\n        .subcommand(\n            Command::new(\"diff\")\n                .about(\"Compare two commits\")\n                .arg(arg!(base: [COMMIT]))\n                .arg(arg!(head: [COMMIT]))\n                .arg(arg!(path: [PATH]).last(true))\n                .arg(\n                    arg!(--color <WHEN>)\n                        .value_parser([\"always\", \"auto\", \"never\"])\n                        .num_args(0..=1)\n                        .require_equals(true)\n                        .default_value(\"auto\")\n                        .default_missing_value(\"always\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"push\")\n                .about(\"pushes things\")\n                .arg(arg!(<REMOTE> \"The remote to target\"))\n                .arg_required_else_help(true),\n        )\n        .subcommand(\n            Command::new(\"add\")\n                .about(\"adds things\")\n                .arg_required_else_help(true)\n                .arg(arg!(<PATH> ... \"Stuff to add\").value_parser(clap::value_parser!(PathBuf))),\n        )\n        .subcommand(\n            Command::new(\"stash\")\n                .args_conflicts_with_subcommands(true)\n                .flatten_help(true)\n                .args(push_args())\n                .subcommand(Command::new(\"push\").args(push_args()))\n                .subcommand(Command::new(\"pop\").arg(arg!([STASH])))\n                .subcommand(Command::new(\"apply\").arg(arg!([STASH]))),\n        )\n}\n\nfn push_args() -> Vec<clap::Arg> {\n    vec![arg!(-m --message <MESSAGE>)]\n}\n\nfn main() {\n    let matches = cli().get_matches();\n\n    match matches.subcommand() {\n        Some((\"clone\", sub_matches)) => {\n            println!(\n                \"Cloning {}\",\n                sub_matches.get_one::<String>(\"REMOTE\").expect(\"required\")\n            );\n        }\n        Some((\"diff\", sub_matches)) => {\n            let color = sub_matches\n                .get_one::<String>(\"color\")\n                .map(|s| s.as_str())\n                .expect(\"defaulted in clap\");\n\n            let mut base = sub_matches.get_one::<String>(\"base\").map(|s| s.as_str());\n            let mut head = sub_matches.get_one::<String>(\"head\").map(|s| s.as_str());\n            let mut path = sub_matches.get_one::<String>(\"path\").map(|s| s.as_str());\n            if path.is_none() {\n                path = head;\n                head = None;\n                if path.is_none() {\n                    path = base;\n                    base = None;\n                }\n            }\n            let base = base.unwrap_or(\"stage\");\n            let head = head.unwrap_or(\"worktree\");\n            let path = path.unwrap_or(\"\");\n            println!(\"Diffing {base}..{head} {path} (color={color})\");\n        }\n        Some((\"push\", sub_matches)) => {\n            println!(\n                \"Pushing to {}\",\n                sub_matches.get_one::<String>(\"REMOTE\").expect(\"required\")\n            );\n        }\n        Some((\"add\", sub_matches)) => {\n            let paths = sub_matches\n                .get_many::<PathBuf>(\"PATH\")\n                .into_iter()\n                .flatten()\n                .collect::<Vec<_>>();\n            println!(\"Adding {paths:?}\");\n        }\n        Some((\"stash\", sub_matches)) => {\n            let stash_command = sub_matches.subcommand().unwrap_or((\"push\", sub_matches));\n            match stash_command {\n                (\"apply\", sub_matches) => {\n                    let stash = sub_matches.get_one::<String>(\"STASH\");\n                    println!(\"Applying {stash:?}\");\n                }\n                (\"pop\", sub_matches) => {\n                    let stash = sub_matches.get_one::<String>(\"STASH\");\n                    println!(\"Popping {stash:?}\");\n                }\n                (\"push\", sub_matches) => {\n                    let message = sub_matches.get_one::<String>(\"message\");\n                    println!(\"Pushing {message:?}\");\n                }\n                (name, _) => {\n                    unreachable!(\"Unsupported subcommand `{name}`\")\n                }\n            }\n        }\n        Some((ext, sub_matches)) => {\n            let args = sub_matches\n                .get_many::<OsString>(\"\")\n                .into_iter()\n                .flatten()\n                .collect::<Vec<_>>();\n            println!(\"Calling out to {ext:?} with {args:?}\");\n        }\n        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable!()\n    }\n\n    // Continued program logic goes here...\n}\n```\n\nGit is an example of several common subcommand patterns.\n\nHelp:\n```console\n$ git\n? failed\nA fictional versioning CLI\n\nUsage: git[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git help\nA fictional versioning CLI\n\nUsage: git[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git help add\nadds things\n\nUsage: git[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n```\n\nA basic argument:\n```console\n$ git add\n? failed\nadds things\n\nUsage: git[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n$ git add Cargo.toml Cargo.lock\nAdding [\"Cargo.toml\", \"Cargo.lock\"]\n\n```\n\nDefault subcommand:\n```console\n$ git stash -h\nUsage: git[EXE] stash [OPTIONS]\n       git[EXE] stash push [OPTIONS]\n       git[EXE] stash pop [STASH]\n       git[EXE] stash apply [STASH]\n       git[EXE] stash help [COMMAND]...\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\ngit[EXE] stash push:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\ngit[EXE] stash pop:\n  -h, --help  Print help\n  [STASH]     \n\ngit[EXE] stash apply:\n  -h, --help  Print help\n  [STASH]     \n\ngit[EXE] stash help:\nPrint this message or the help of the given subcommand(s)\n  [COMMAND]...  Print help for the subcommand(s)\n\n$ git stash push -h\nUsage: git[EXE] stash push [OPTIONS]\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git stash pop -h\nUsage: git[EXE] stash pop [STASH]\n\nArguments:\n  [STASH]  \n\nOptions:\n  -h, --help  Print help\n\n$ git stash -m \"Prototype\"\nPushing Some(\"Prototype\")\n\n$ git stash pop\nPopping None\n\n$ git stash push -m \"Prototype\"\nPushing Some(\"Prototype\")\n\n$ git stash pop\nPopping None\n\n```\n\nExternal subcommands:\n```console\n$ git custom-tool arg1 --foo bar\nCalling out to \"custom-tool\" with [\"arg1\", \"--foo\", \"bar\"]\n\n```\n\nLast argument:\n```console\n$ git diff --help\nCompare two commits\n\nUsage: git[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]\n\nArguments:\n  [COMMIT]  \n  [COMMIT]  \n  [PATH]    \n\nOptions:\n      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]\n  -h, --help            Print help\n\n$ git diff\nDiffing stage..worktree  (color=auto)\n\n$ git diff ./src\nDiffing stage..worktree ./src (color=auto)\n\n$ git diff HEAD ./src\nDiffing HEAD..worktree ./src (color=auto)\n\n$ git diff HEAD~~ -- HEAD\nDiffing HEAD~~..worktree HEAD (color=auto)\n\n$ git diff --color\nDiffing stage..worktree  (color=always)\n\n$ git diff --color=never\nDiffing stage..worktree  (color=never)\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/escaped_positional.rs",
      "content": "# Example (Builder API)\n\n```rust\nuse clap::{arg, command, value_parser, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(arg!(eff: -f).action(ArgAction::SetTrue))\n        .arg(arg!(pea: -p <PEAR>).value_parser(value_parser!(String)))\n        .arg(\n            // Indicates that `slop` is only accessible after `--`.\n            arg!(slop: [SLOP])\n                .num_args(1..)\n                .last(true)\n                .value_parser(value_parser!(String)),\n        )\n        .get_matches();\n\n    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...\n\n    // -f used: true\n    println!(\"-f used: {:?}\", matches.get_flag(\"eff\"));\n    // -p's value: Some(\"bob\")\n    println!(\"-p's value: {:?}\", matches.get_one::<String>(\"pea\"));\n    // 'slops' values: Some([\"sloppy\", \"slop\", \"slop\"])\n    println!(\n        \"'slops' values: {:?}\",\n        matches\n            .get_many::<String>(\"slop\")\n            .map(|vals| vals.collect::<Vec<_>>())\n            .unwrap_or_default()\n    );\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`cargo` feature flag][crate::_features].**\n\nYou can use `--` to escape further arguments.\n\nLet's see what this looks like in the help:\n```console\n$ escaped-positional --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]\n\nArguments:\n  [SLOP]...  \n\nOptions:\n  -f             \n  -p <PEAR>      \n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nHere is a baseline without any arguments:\n```console\n$ escaped-positional\n-f used: false\n-p's value: None\n'slops' values: []\n\n```\n\nNotice that we can't pass positional arguments before `--`:\n```console\n$ escaped-positional foo bar\n? failed\nerror: unexpected argument 'foo' found\n\nUsage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]\n\nFor more information, try '--help'.\n\n```\n\nBut you can after:\n```console\n$ escaped-positional -f -p=bob -- sloppy slop slop\n-f used: true\n-p's value: Some(\"bob\")\n'slops' values: [\"sloppy\", \"slop\", \"slop\"]\n\n```\n\nAs mentioned, the parser will directly pass everything through:\n```console\n$ escaped-positional -- -f -p=bob sloppy slop slop\n-f used: false\n-p's value: None\n'slops' values: [\"-f\", \"-p=bob\", \"sloppy\", \"slop\", \"slop\"]\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_faq.rs",
      "content": "# Documentation: FAQ\n\n1. [Comparisons](#comparisons)\n   1. [How does `clap` compare to structopt?](#how-does-clap-compare-to-structopt)\n   2. [What are some reasons to use `clap`? (The Pitch)](#what-are-some-reasons-to-use-clap-the-pitch)\n   3. [What are some reasons *not* to use `clap`? (The Anti Pitch)](#what-are-some-reasons-not-to-use-clap-the-anti-pitch)\n   4. [Reasons to use `clap`](#reasons-to-use-clap)\n2. [How many approaches are there to create a parser?](#how-many-approaches-are-there-to-create-a-parser)\n3. [When should I use the builder vs derive APIs?](#when-should-i-use-the-builder-vs-derive-apis)\n4. [Why is there a default subcommand of help?](#why-is-there-a-default-subcommand-of-help)\n\n### Comparisons\n\nFirst, let me say that these comparisons are highly subjective, and not meant\nin a critical or harsh manner. All the argument parsing libraries out there (to\ninclude `clap`) have their own strengths and weaknesses. Sometimes it just\ncomes down to personal taste when all other factors are equal. When in doubt,\ntry them all and pick one that you enjoy :). There's plenty of room in the Rust\ncommunity for multiple implementations!\n\nFor less detailed but more broad comparisons, see\n[argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs).\n\n#### How does `clap` compare to [structopt](https://github.com/TeXitoi/structopt)?\n\nSimple! `clap` *is* `structopt`.  `structopt` started as a derive API built on\ntop of clap v2.  With clap v3, we've forked structopt and integrated it\ndirectly into clap.  structopt is in\n[maintenance mode](https://github.com/TeXitoi/structopt/issues/516#issuecomment-989566094)\nwith the release of `clap_derive`.\n\nThe benefits of integrating `structopt` and `clap` are:\n- Easier cross-linking in documentation\n- Documentation parity\n- Tighter design feedback loop, ensuring all new features are designed with\n  derives in mind and easier to change `clap` in response to `structopt` bugs.\n- Clearer endorsement of `structopt`\n\nSee also\n- [`clap` v3 CHANGELOG](https://github.com/clap-rs/clap/blob/v3-master/CHANGELOG.md#300---2021-12-31)\n- [`structopt` migration guide](https://github.com/clap-rs/clap/blob/v3-master/CHANGELOG.md#migrate-structopt)\n\n#### What are some reasons to use `clap`? (The Pitch)\n\n`clap` is as fast, and as lightweight as possible while still giving all the features you'd expect from a modern argument parser. In fact, for the amount and type of features `clap` offers it remains about as fast as `getopts`. If you use `clap`, when you just need some simple arguments parsed, you'll find it's a walk in the park. `clap` also makes it possible to represent extremely complex and advanced requirements without too much thought. `clap` aims to be intuitive, easy to use, and fully capable for wide variety use cases and needs.\n\n#### What are some reasons *not* to use `clap`? (The Anti Pitch)\n\nDepending on the style in which you choose to define the valid arguments, `clap` can be very verbose. `clap` also offers so many finetuning knobs and dials, that learning everything can seem overwhelming. I strive to keep the simple cases simple, but when turning all those custom dials it can get complex. `clap` is also opinionated about parsing. Even though so much can be tweaked and tuned with `clap` (and I'm adding more all the time), there are still certain features which `clap` implements in specific ways that may be contrary to some users' use-cases.\n\n#### Reasons to use `clap`\n\n * You want all the nice CLI features your users may expect, yet you don't want to implement them all yourself. You'd like to focus on your application, not argument parsing.\n * In addition to the point above, you don't want to sacrifice performance to get all those nice features.\n * You have complex requirements/conflicts between your various valid args.\n * You want to use subcommands (although other libraries also support subcommands, they are not nearly as feature rich as those provided by `clap`).\n * You want some sort of custom validation built into the argument parsing process, instead of as part of your application (which allows for earlier failures, better error messages, more cohesive experience, etc.).\n\n### How many approaches are there to create a parser?\n\nThe following APIs are supported:\n- [Derive][crate::_derive::_tutorial]\n- [Builder][crate::_tutorial]\n\nPreviously, we supported:\n- [YAML](https://github.com/clap-rs/clap/issues/3087)\n- [docopt](http://docopt.org/)-inspired [usage parser](https://github.com/clap-rs/clap/issues/3086)\n- [`clap_app!`](https://github.com/clap-rs/clap/issues/2835)\n\nThere are also experiments with other APIs:\n- [fncmd](https://github.com/yuhr/fncmd): function attribute\n- [clap-serde](https://github.com/aobatact/clap-serde): create an `Command` from a deserializer\n\n### When should I use the builder vs derive APIs?\n\nOur default answer is to use the [Derive API][crate::_derive::_tutorial]:\n- Easier to read, write, and modify\n- Easier to keep the argument declaration and reading of argument in sync\n- Easier to reuse, e.g. [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)\n\nThe [Builder API][crate::_tutorial] is a lower-level API that someone might want to use for\n- Faster compile times if you aren't already using other procedural macros\n- More flexibility, e.g. you can look up an [arguments values][crate::ArgMatches::get_many],\n  their [ordering with other arguments][crate::ArgMatches::indices_of], and [what set\n  them][crate::ArgMatches::value_source].  The Derive API can only report values and not\n  indices of or other data.\n\nYou can [interop between Derive and Builder APIs][crate::_derive#mixing-builder-and-derive-apis].\n\n### Why is there a default subcommand of help?\n\nThere is only a default subcommand of `help` when other subcommands have been defined manually. So it's opt-in(ish), being that you only get a `help` subcommand if you're actually using subcommands.\n\nAlso, if the user defined a `help` subcommand themselves, the auto-generated one wouldn't be added (meaning it's only generated if the user hasn't defined one themselves).\n"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/pacman.rs",
      "content": "# Example: pacman-like CLI (Builder API)\n\n```rust\nuse clap::{Arg, ArgAction, Command};\n\nfn main() {\n    let matches = Command::new(\"pacman\")\n        .about(\"package manager utility\")\n        .version(\"5.2.1\")\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        // Query subcommand\n        //\n        // Only a few of its arguments are implemented below.\n        .subcommand(\n            Command::new(\"query\")\n                .short_flag('Q')\n                .long_flag(\"query\")\n                .about(\"Query the package database.\")\n                .arg(\n                    Arg::new(\"search\")\n                        .short('s')\n                        .long(\"search\")\n                        .help(\"search locally installed packages for matching strings\")\n                        .conflicts_with(\"info\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                )\n                .arg(\n                    Arg::new(\"info\")\n                        .long(\"info\")\n                        .short('i')\n                        .conflicts_with(\"search\")\n                        .help(\"view package information\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                ),\n        )\n        // Sync subcommand\n        //\n        // Only a few of its arguments are implemented below.\n        .subcommand(\n            Command::new(\"sync\")\n                .short_flag('S')\n                .long_flag(\"sync\")\n                .about(\"Synchronize packages.\")\n                .arg(\n                    Arg::new(\"search\")\n                        .short('s')\n                        .long(\"search\")\n                        .conflicts_with(\"info\")\n                        .action(ArgAction::Set)\n                        .num_args(1..)\n                        .help(\"search remote repositories for matching strings\"),\n                )\n                .arg(\n                    Arg::new(\"info\")\n                        .long(\"info\")\n                        .conflicts_with(\"search\")\n                        .short('i')\n                        .action(ArgAction::SetTrue)\n                        .help(\"view package information\"),\n                )\n                .arg(\n                    Arg::new(\"package\")\n                        .help(\"packages\")\n                        .required_unless_present(\"search\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                ),\n        )\n        .get_matches();\n\n    match matches.subcommand() {\n        Some((\"sync\", sync_matches)) => {\n            if sync_matches.contains_id(\"search\") {\n                let packages: Vec<_> = sync_matches\n                    .get_many::<String>(\"search\")\n                    .expect(\"contains_id\")\n                    .map(|s| s.as_str())\n                    .collect();\n                let values = packages.join(\", \");\n                println!(\"Searching for {values}...\");\n                return;\n            }\n\n            let packages: Vec<_> = sync_matches\n                .get_many::<String>(\"package\")\n                .expect(\"is present\")\n                .map(|s| s.as_str())\n                .collect();\n            let values = packages.join(\", \");\n\n            if sync_matches.get_flag(\"info\") {\n                println!(\"Retrieving info for {values}...\");\n            } else {\n                println!(\"Installing {values}...\");\n            }\n        }\n        Some((\"query\", query_matches)) => {\n            if let Some(packages) = query_matches.get_many::<String>(\"info\") {\n                let comma_sep = packages.map(|s| s.as_str()).collect::<Vec<_>>().join(\", \");\n                println!(\"Retrieving info for {comma_sep}...\");\n            } else if let Some(queries) = query_matches.get_many::<String>(\"search\") {\n                let comma_sep = queries.map(|s| s.as_str()).collect::<Vec<_>>().join(\", \");\n                println!(\"Searching Locally for {comma_sep}...\");\n            } else {\n                println!(\"Displaying all locally installed packages...\");\n            }\n        }\n        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable\n    }\n}\n```\n\n[`pacman`](https://wiki.archlinux.org/index.php/pacman) defines subcommands via flags.\n\nHere, `-S` is a short flag subcommand:\n```console\n$ pacman -S package\nInstalling package...\n\n```\n\nHere `--sync` is a long flag subcommand:\n```console\n$ pacman --sync package\nInstalling package...\n\n```\n\nNow the short flag subcommand (`-S`) with a long flag:\n```console\n$ pacman -S --search name\nSearching for name...\n\n```\n\nAnd the various forms of short flags that work:\n```console\n$ pacman -S -s name\nSearching for name...\n\n$ pacman -Ss name\nSearching for name...\n\n```\n*(users can \"stack\" short subcommands with short flags or with other short flag subcommands)*\n\nIn the help, this looks like:\n```console\n$ pacman -h\npackage manager utility\n\nUsage: pacman[EXE] <COMMAND>\n\nCommands:\n  query, -Q, --query  Query the package database.\n  sync, -S, --sync    Synchronize packages.\n  help                Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ pacman -S -h\nSynchronize packages.\n\nUsage: pacman[EXE] {sync|--sync|-S} [OPTIONS] [package]...\n\nArguments:\n  [package]...  packages\n\nOptions:\n  -s, --search <search>...  search remote repositories for matching strings\n  -i, --info                view package information\n  -h, --help                Print help\n\n```\n\nAnd errors:\n```console\n$ pacman -S -s foo -i bar\n? failed\nerror: the argument '--search <search>...' cannot be used with '--info'\n\nUsage: pacman[EXE] {sync|--sync|-S} --search <search>... <package>...\n\nFor more information, try '--help'.\n\n```\n\n<div class=\"warning\">\n\n**NOTE:** Keep in mind that subcommands, flags, and long flags are *case sensitive*: `-Q` and `-q` are different flags/subcommands. For example, you can have both `-Q` subcommand and `-q` flag, and they will be properly disambiguated.\nLet's make a quick program to illustrate.\n\n</div>"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/find.rs",
      "content": "# Example: find-like CLI (Builder API)\n\n```rust\nuse std::collections::BTreeMap;\n\nuse clap::{command, value_parser, Arg, ArgAction, ArgGroup, ArgMatches, Command};\n\nfn main() {\n    let matches = cli().get_matches();\n    let values = Value::from_matches(&matches);\n    println!(\"{values:#?}\");\n}\n\nfn cli() -> Command {\n    command!()\n        .group(ArgGroup::new(\"tests\").multiple(true))\n        .next_help_heading(\"TESTS\")\n        .args([\n            position_sensitive_flag(Arg::new(\"empty\"))\n                .long(\"empty\")\n                .action(ArgAction::Append)\n                .help(\"File is empty and is either a regular file or a directory\")\n                .group(\"tests\"),\n            Arg::new(\"name\")\n                .long(\"name\")\n                .action(ArgAction::Append)\n                .help(\"Base of file name (the path with the leading directories removed) matches shell pattern pattern\")\n                .group(\"tests\")\n        ])\n        .group(ArgGroup::new(\"operators\").multiple(true))\n        .next_help_heading(\"OPERATORS\")\n        .args([\n            position_sensitive_flag(Arg::new(\"or\"))\n                .short('o')\n                .long(\"or\")\n                .action(ArgAction::Append)\n                .help(\"expr2 is not evaluate if exp1 is true\")\n                .group(\"operators\"),\n            position_sensitive_flag(Arg::new(\"and\"))\n                .short('a')\n                .long(\"and\")\n                .action(ArgAction::Append)\n                .help(\"Same as `expr1 expr1`\")\n                .group(\"operators\"),\n        ])\n}\n\nfn position_sensitive_flag(arg: Arg) -> Arg {\n    // Flags don't track the position of each occurrence, so we need to emulate flags with\n    // value-less options to get the same result\n    arg.num_args(0)\n        .value_parser(value_parser!(bool))\n        .default_missing_value(\"true\")\n        .default_value(\"false\")\n}\n\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum Value {\n    Bool(bool),\n    String(String),\n}\n\nimpl Value {\n    pub fn from_matches(matches: &ArgMatches) -> Vec<(clap::Id, Self)> {\n        let mut values = BTreeMap::new();\n        for id in matches.ids() {\n            if matches.try_get_many::<clap::Id>(id.as_str()).is_ok() {\n                // ignore groups\n                continue;\n            }\n            let value_source = matches\n                .value_source(id.as_str())\n                .expect(\"id came from matches\");\n            if value_source != clap::parser::ValueSource::CommandLine {\n                // Any other source just gets tacked on at the end (like default values)\n                continue;\n            }\n            if Self::extract::<String>(matches, id, &mut values) {\n                continue;\n            }\n            if Self::extract::<bool>(matches, id, &mut values) {\n                continue;\n            }\n            unimplemented!(\"unknown type for {id}: {matches:?}\");\n        }\n        values.into_values().collect::<Vec<_>>()\n    }\n\n    fn extract<T: Clone + Into<Value> + Send + Sync + 'static>(\n        matches: &ArgMatches,\n        id: &clap::Id,\n        output: &mut BTreeMap<usize, (clap::Id, Self)>,\n    ) -> bool {\n        match matches.try_get_many::<T>(id.as_str()) {\n            Ok(Some(values)) => {\n                for (value, index) in values.zip(\n                    matches\n                        .indices_of(id.as_str())\n                        .expect(\"id came from matches\"),\n                ) {\n                    output.insert(index, (id.clone(), value.clone().into()));\n                }\n                true\n            }\n            Ok(None) => {\n                unreachable!(\"`ids` only reports what is present\")\n            }\n            Err(clap::parser::MatchesError::UnknownArgument { .. }) => {\n                unreachable!(\"id came from matches\")\n            }\n            Err(clap::parser::MatchesError::Downcast { .. }) => false,\n            Err(_) => {\n                unreachable!(\"id came from matches\")\n            }\n        }\n    }\n}\n\nimpl From<String> for Value {\n    fn from(other: String) -> Self {\n        Self::String(other)\n    }\n}\n\nimpl From<bool> for Value {\n    fn from(other: bool) -> Self {\n        Self::Bool(other)\n    }\n}\n```\n\n`find` is an example of position-sensitive flags\n\n```console\n$ find --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: find[EXE] [OPTIONS]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\nTESTS:\n      --empty        File is empty and is either a regular file or a directory\n      --name <name>  Base of file name (the path with the leading directories removed) matches shell\n                     pattern pattern\n\nOPERATORS:\n  -o, --or   expr2 is not evaluate if exp1 is true\n  -a, --and  Same as `expr1 expr1`\n\n$ find --empty -o --name .keep\n[\n    (\n        \"empty\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"or\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"name\",\n        String(\n            \".keep\",\n        ),\n    ),\n]\n\n$ find --empty -o --name .keep -o --name foo\n[\n    (\n        \"empty\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"or\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"name\",\n        String(\n            \".keep\",\n        ),\n    ),\n    (\n        \"or\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"name\",\n        String(\n            \"foo\",\n        ),\n    ),\n]\n\n```\n"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_derive/_tutorial.rs",
      "content": "## Tutorial for the Derive API\n\n*See the side bar for the Table of Contents*\n\n## Quick Start\n\nYou can create an application declaratively with a `struct` and some\nattributes.\n\nFirst, ensure `clap` is available with the [`derive` feature flag][crate::_features]:\n```console\n$ cargo add clap --features derive\n```\n\nHere is a preview of the type of application you can make:\n```rust\nuse std::path::PathBuf;\n\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Optional name to operate on\n    name: Option<String>,\n\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    config: Option<PathBuf>,\n\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    debug: u8,\n\n    #[command(subcommand)]\n    command: Option<Commands>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// does testing things\n    Test {\n        /// lists test values\n        #[arg(short, long)]\n        list: bool,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check the value provided by positional arguments, or option arguments\n    if let Some(name) = cli.name.as_deref() {\n        println!(\"Value for name: {name}\");\n    }\n\n    if let Some(config_path) = cli.config.as_deref() {\n        println!(\"Value for config: {}\", config_path.display());\n    }\n\n    // You can see how many times a particular flag or argument occurred\n    // Note, only flags can have multiple occurrences\n    match cli.debug {\n        0 => println!(\"Debug mode is off\"),\n        1 => println!(\"Debug mode is kind of on\"),\n        2 => println!(\"Debug mode is on\"),\n        _ => println!(\"Don't be crazy\"),\n    }\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Some(Commands::Test { list }) => {\n            if *list {\n                println!(\"Printing testing lists...\");\n            } else {\n                println!(\"Not printing testing lists...\");\n            }\n        }\n        None => {}\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n```console\n$ 01_quick_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 01_quick_derive[EXE] [OPTIONS] [NAME] [COMMAND]\n\nCommands:\n  test  does testing things\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  [NAME]  Optional name to operate on\n\nOptions:\n  -c, --config <FILE>  Sets a custom config file\n  -d, --debug...       Turn debugging information on\n  -h, --help           Print help\n  -V, --version        Print version\n\n```\n\nBy default, the program does nothing:\n```console\n$ 01_quick_derive\nDebug mode is off\n\n```\n\nBut you can mix and match the various features\n```console\n$ 01_quick_derive -dd test\nDebug mode is on\nNot printing testing lists...\n\n```\n\nSee also\n- [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]\n- The [cookbook][crate::_cookbook] for more application-focused examples\n\n## Configuring the Parser\n\nYou use derive [`Parser`][crate::Parser] to start building a parser.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"MyApp\")]\n#[command(version = \"1.0\")]\n#[command(about = \"Does awesome things\", long_about = None)]\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n\n```console\n$ 02_apps_derive --help\nDoes awesome things\n\nUsage: 02_apps_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>  \n      --one <ONE>  \n  -h, --help       Print help\n  -V, --version    Print version\n\n$ 02_apps_derive --version\nMyApp 1.0\n\n```\n\nYou can use [`#[command(version, about)]` attribute defaults][super#command-attributes] on the struct to fill these fields in from your `Cargo.toml` file.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)] // Read from `Cargo.toml`\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n```console\n$ 02_crate_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_crate_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>  \n      --one <ONE>  \n  -h, --help       Print help\n  -V, --version    Print version\n\n$ 02_crate_derive --version\nclap [..]\n\n```\n\nYou can use `#[command]` attributes on the struct to change the application level behavior of clap.  Any [`Command`][crate::Command] builder function can be used as an attribute, like [`Command::next_line_help`].\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\n#[command(next_line_help = true)]\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n```console\n$ 02_app_settings_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_app_settings_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>\n          \n      --one <ONE>\n          \n  -h, --help\n          Print help\n  -V, --version\n          Print version\n\n```\n\n## Adding Arguments\n\n1. [Positionals](#positionals)\n2. [Options](#options)\n3. [Flags](#flags)\n4. [Optional](#optional)\n5. [Defaults](#defaults)\n6. [Subcommands](#subcommands)\n\nArguments are inferred from the fields of your struct.\n\n### Positionals\n\nBy default, struct fields define positional arguments:\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    name: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_03_positional_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_derive[EXE] <NAME>\n\nArguments:\n  <NAME>  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_derive\n? 2\nerror: the following required arguments were not provided:\n  <NAME>\n\nUsage: 03_03_positional_derive[EXE] <NAME>\n\nFor more information, try '--help'.\n\n$ 03_03_positional_derive bob\nname: \"bob\"\n\n```\n\nNote that the [default `ArgAction` is `Set`][super#arg-types].  To\naccept multiple values, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append] via `Vec`:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    name: Vec<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_03_positional_mult_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_mult_derive[EXE] [NAME]...\n\nArguments:\n  [NAME]...  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_mult_derive\nname: []\n\n$ 03_03_positional_mult_derive bob\nname: [\"bob\"]\n\n$ 03_03_positional_mult_derive bob john\nname: [\"bob\", \"john\"]\n\n```\n\n### Options\n\nYou can name your arguments with a flag:\n- Intent of the value is clearer\n- Order doesn't matter\n\nTo specify the flags for an argument, you can use [`#[arg(short = 'n')]`][Arg::short] and/or\n[`#[arg(long = \"name\")]`][Arg::long] attributes on a field.  When no value is given (e.g.\n`#[arg(short)]`), the flag is inferred from the field's name.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    name: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_02_option_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_derive[EXE] --name <NAME>\n\nOptions:\n  -n, --name <NAME>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_derive\n? 2\nerror: the following required arguments were not provided:\n  --name <NAME>\n\nUsage: 03_02_option_derive[EXE] --name <NAME>\n\nFor more information, try '--help'.\n\n$ 03_02_option_derive --name bob\nname: \"bob\"\n\n$ 03_02_option_derive --name=bob\nname: \"bob\"\n\n$ 03_02_option_derive -n bob\nname: \"bob\"\n\n$ 03_02_option_derive -n=bob\nname: \"bob\"\n\n$ 03_02_option_derive -nbob\nname: \"bob\"\n\n```\n\nNote that the [default `ArgAction` is `Set`][super#arg-types].  To\naccept multiple occurrences, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append] via `Vec`:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    name: Vec<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_02_option_mult_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_mult_derive[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <NAME>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_mult_derive\nname: []\n\n$ 03_02_option_mult_derive --name bob\nname: [\"bob\"]\n\n$ 03_02_option_mult_derive --name bob --name john\nname: [\"bob\", \"john\"]\n\n$ 03_02_option_mult_derive --name bob --name=john -n tom -n=chris -nsteve\nname: [\"bob\", \"john\", \"tom\", \"chris\", \"steve\"]\n\n```\n\n### Flags\n\nFlags can also be switches that can be on/off:\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    verbose: bool,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"verbose: {:?}\", cli.verbose);\n}\n```\n```console\n$ 03_01_flag_bool_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_bool_derive[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose  \n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_01_flag_bool_derive\nverbose: false\n\n$ 03_01_flag_bool_derive --verbose\nverbose: true\n\n$ 03_01_flag_bool_derive --verbose --verbose\n? failed\nerror: the argument '--verbose' cannot be used multiple times\n\nUsage: 03_01_flag_bool_derive[EXE] [OPTIONS]\n\nFor more information, try '--help'.\n\n```\n\nNote that the [default `ArgAction` for a `bool` field is\n`SetTrue`][super#arg-types].  To accept multiple flags, override the [action][Arg::action] with\n[`Count`][crate::ArgAction::Count]:\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbose: u8,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"verbose: {:?}\", cli.verbose);\n}\n```\n```console\n$ 03_01_flag_count_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_count_derive[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose...  \n  -h, --help        Print help\n  -V, --version     Print version\n\n$ 03_01_flag_count_derive\nverbose: 0\n\n$ 03_01_flag_count_derive --verbose\nverbose: 1\n\n$ 03_01_flag_count_derive --verbose --verbose\nverbose: 2\n\n```\n\nThis also shows that any[`Arg`][crate::Args] method may be used as an attribute.\n\n### Optional\n\nBy default, arguments are assumed to be [`required`][crate::Arg::required].\nTo make an argument optional, wrap the field's type in `Option`:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    name: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_06_optional_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_06_optional_derive[EXE] [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_06_optional_derive\nname: None\n\n$ 03_06_optional_derive bob\nname: Some(\"bob\")\n\n```\n\n### Defaults\n\nWe've previously showed that arguments can be [`required`][crate::Arg::required] or optional.\nWhen optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can\nset [`#[arg(default_value_t)]`][super#arg-attributes].\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(default_value_t = 2020)]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"port: {:?}\", cli.port);\n}\n```\n```console\n$ 03_05_default_values_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_05_default_values_derive[EXE] [PORT]\n\nArguments:\n  [PORT]  [default: 2020]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_05_default_values_derive\nport: 2020\n\n$ 03_05_default_values_derive 22\nport: 22\n\n```\n\n### Subcommands\n\nSubcommands are derived with `#[derive(Subcommand)]` and be added via\n[`#[command(subcommand)]` attribute][super#command-attributes] on the field using that type.\nEach instance of a [Subcommand][crate::Subcommand] can have its own version, author(s), Args,\nand even its own subcommands.\n\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\n#[command(propagate_version = true)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Adds files to myapp\n    Add { name: Option<String> },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Commands::Add { name } => {\n            println!(\"'myapp add' was used, name is: {name:?}\");\n        }\n    }\n}\n```\nWe used a struct-variant to define the `add` subcommand.\nAlternatively, you can use a struct for your subcommand's arguments:\n```rust\nuse clap::{Args, Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\n#[command(propagate_version = true)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Adds files to myapp\n    Add(AddArgs),\n}\n\n#[derive(Args)]\nstruct AddArgs {\n    name: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Commands::Add(name) => {\n            println!(\"'myapp add' was used, name is: {:?}\", name.name);\n        }\n    }\n}\n```\n\n```console\n$ 03_04_subcommands_derive help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands_derive[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands_derive help add\nAdds files to myapp\n\nUsage: 03_04_subcommands_derive[EXE] add [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands_derive add bob\n'myapp add' was used, name is: Some(\"bob\")\n\n```\n\nWhen specifying commands with `command: Commands`, they are [required][crate::Command::subcommand_required].\nBy default, a missing subcommand will [show help rather than error][crate::Command::arg_required_else_help].\n```console\n$ 03_04_subcommands_derive\n? failed\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands_derive[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n```\nTo make a subcommand optional, wrap it in an `Option` (e.g. `command: Option<Commands>`).\n\nSince we specified [`#[command(propagate_version = true)]`][crate::Command::propagate_version],\nthe `--version` flag is available in all subcommands:\n```console\n$ 03_04_subcommands_derive --version\nclap [..]\n\n$ 03_04_subcommands_derive add --version\nclap-add [..]\n\n```\n\n## Validation\n\n1. [Enumerated values](#enumerated-values)\n2. [Validated values](#validated-values)\n3. [Argument Relations](#argument-relations)\n4. [Custom Validation](#custom-validation)\n\nAn appropriate default parser/validator will be selected for the field's type.  See\n[`value_parser!`][crate::value_parser!] for more details.\n\n### Enumerated values\n\nFor example, if you have arguments of specific values you want to test for, you can derive\n[`ValueEnum`][super#valueenum-attributes]\n(any [`PossibleValue`] builder function can be used as a `#[value]` attribute on enum variants).\n\nThis allows you specify the valid values for that argument. If the user does not use one of\nthose specific values, they will receive a graceful exit with error message informing them\nof the mistake, and what the possible valid values are\n\n```rust\nuse clap::{Parser, ValueEnum};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// What mode to run the program in\n    #[arg(value_enum)]\n    mode: Mode,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]\nenum Mode {\n    /// Run swiftly\n    Fast,\n    /// Crawl slowly but steadily\n    ///\n    /// This paragraph is ignored because there is no long help text for possible values.\n    Slow,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    match cli.mode {\n        Mode::Fast => {\n            println!(\"Hare\");\n        }\n        Mode::Slow => {\n            println!(\"Tortoise\");\n        }\n    }\n}\n```\n```console\n$ 04_01_enum_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum_derive[EXE] <MODE>\n\nArguments:\n  <MODE>\n          What mode to run the program in\n\n          Possible values:\n          - fast: Run swiftly\n          - slow: Crawl slowly but steadily\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n$ 04_01_enum_derive -h\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum_derive[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help (see more with '--help')\n  -V, --version  Print version\n\n$ 04_01_enum_derive fast\nHare\n\n$ 04_01_enum_derive slow\nTortoise\n\n$ 04_01_enum_derive medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\n### Validated values\n\nMore generally, you can validate and parse into any data type with [`Arg::value_parser`].\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    #[arg(value_parser = clap::value_parser!(u16).range(1..))]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n```\n```console\n$ 04_02_parse_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_parse_derive[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_parse_derive 22\nPORT = 22\n\n$ 04_02_parse_derive foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': invalid digit found in string\n\nFor more information, try '--help'.\n\n$ 04_02_parse_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': 0 is not in 1..=65535\n\nFor more information, try '--help'.\n\n```\n\nA [custom parser][TypedValueParser] can be used to improve the error messages or provide additional validation:\n\n```rust\nuse std::ops::RangeInclusive;\n\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    #[arg(value_parser = port_in_range)]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n\nconst PORT_RANGE: RangeInclusive<usize> = 1..=65535;\n\nfn port_in_range(s: &str) -> Result<u16, String> {\n    let port: usize = s\n        .parse()\n        .map_err(|_| format!(\"`{s}` isn't a port number\"))?;\n    if PORT_RANGE.contains(&port) {\n        Ok(port as u16)\n    } else {\n        Err(format!(\n            \"port not in range {}-{}\",\n            PORT_RANGE.start(),\n            PORT_RANGE.end()\n        ))\n    }\n}\n```\n```console\n$ 04_02_validate_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_validate_derive[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_validate_derive 22\nPORT = 22\n\n$ 04_02_validate_derive foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number\n\nFor more information, try '--help'.\n\n$ 04_02_validate_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': port not in range 1-65535\n\nFor more information, try '--help'.\n\n```\n\nSee [`Arg::value_parser`][crate::Arg::value_parser] for more details.\n\n### Argument Relations\n\nYou can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even\n[`ArgGroup`][crate::ArgGroup]s.\n\n[`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list\neach individually, or when you want a rule to apply \"any but not all\" arguments.\n\nPerhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one\nargument to be present out of a given set. Imagine that you had multiple arguments, and you\nwant one of them to be required, but making all of them required isn't feasible because perhaps\nthey conflict with each other.\n\n[`ArgGroup`][crate::ArgGroup]s are automatically created for a `struct` with its\n[`ArgGroup::id`][crate::ArgGroup::id] being the struct's name.\n\n```rust\nuse clap::{Args, Parser};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[command(flatten)]\n    vers: Vers,\n\n    /// some regular input\n    #[arg(group = \"input\")]\n    input_file: Option<String>,\n\n    /// some special input argument\n    #[arg(long, group = \"input\")]\n    spec_in: Option<String>,\n\n    #[arg(short, requires = \"input\")]\n    config: Option<String>,\n}\n\n#[derive(Args)]\n#[group(required = true, multiple = false)]\nstruct Vers {\n    /// set version manually\n    #[arg(long, value_name = \"VER\")]\n    set_ver: Option<String>,\n\n    /// auto inc major\n    #[arg(long)]\n    major: bool,\n\n    /// auto inc minor\n    #[arg(long)]\n    minor: bool,\n\n    /// auto inc patch\n    #[arg(long)]\n    patch: bool,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set_ver was used to set the version manually\n    let vers = &cli.vers;\n    let version = if let Some(ver) = vers.set_ver.as_deref() {\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (vers.major, vers.minor, vers.patch);\n        match (maj, min, pat) {\n            (true, _, _) => major += 1,\n            (_, true, _) => minor += 1,\n            (_, _, true) => patch += 1,\n            _ => unreachable!(),\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if let Some(config) = cli.config.as_deref() {\n        let input = cli\n            .input_file\n            .as_deref()\n            .unwrap_or_else(|| cli.spec_in.as_deref().unwrap());\n        println!(\"Doing work using input {input} and config {config}\");\n    }\n}\n```\n```console\n$ 04_03_relations_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_03_relations_derive[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_03_relations_derive\n? failed\nerror: the following required arguments were not provided:\n  <--set-ver <VER>|--major|--minor|--patch>\n\nUsage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major\nVersion: 2.2.3\n\n$ 04_03_relations_derive --major --minor\n? failed\nerror: the argument '--major' cannot be used with '--minor'\n\nUsage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major -c config.toml\n? failed\nerror: the following required arguments were not provided:\n  <INPUT_FILE|--spec-in <SPEC_IN>>\n\nUsage: 04_03_relations_derive[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n### Custom Validation\n\nAs a last resort, you can create custom errors with the basics of clap's formatting.\n\n```rust\nuse clap::error::ErrorKind;\nuse clap::{CommandFactory, Parser};\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// set version manually\n    #[arg(long, value_name = \"VER\")]\n    set_ver: Option<String>,\n\n    /// auto inc major\n    #[arg(long)]\n    major: bool,\n\n    /// auto inc minor\n    #[arg(long)]\n    minor: bool,\n\n    /// auto inc patch\n    #[arg(long)]\n    patch: bool,\n\n    /// some regular input\n    input_file: Option<String>,\n\n    /// some special input argument\n    #[arg(long)]\n    spec_in: Option<String>,\n\n    #[arg(short)]\n    config: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = cli.set_ver.as_deref() {\n        if cli.major || cli.minor || cli.patch {\n            let mut cmd = Cli::command();\n            cmd.error(\n                ErrorKind::ArgumentConflict,\n                \"Can't do relative and absolute version change\",\n            )\n            .exit();\n        }\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (cli.major, cli.minor, cli.patch);\n        match (maj, min, pat) {\n            (true, false, false) => major += 1,\n            (false, true, false) => minor += 1,\n            (false, false, true) => patch += 1,\n            _ => {\n                let mut cmd = Cli::command();\n                cmd.error(\n                    ErrorKind::ArgumentConflict,\n                    \"Can only modify one version field\",\n                )\n                .exit();\n            }\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if let Some(config) = cli.config.as_deref() {\n        let input = cli\n            .input_file\n            .as_deref()\n            // 'or' is preferred to 'or_else' here since `Option::as_deref` is 'const'\n            .or(cli.spec_in.as_deref())\n            .unwrap_or_else(|| {\n                let mut cmd = Cli::command();\n                cmd.error(\n                    ErrorKind::MissingRequiredArgument,\n                    \"INPUT_FILE or --spec-in is required when using --config\",\n                )\n                .exit()\n            });\n        println!(\"Doing work using input {input} and config {config}\");\n    }\n}\n```\n```console\n$ 04_04_custom_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_04_custom_derive[EXE] [OPTIONS] [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_04_custom_derive\n? failed\nerror: Can only modify one version field\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major\nVersion: 2.2.3\n\n$ 04_04_custom_derive --major --minor\n? failed\nerror: Can only modify one version field\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major -c config.toml\n? failed\nVersion: 2.2.3\nerror: INPUT_FILE or --spec-in is required when using --config\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n## Testing\n\nclap reports most development errors as `debug_assert!`s.  Rather than checking every\nsubcommand, you should have a test that calls\n[`Command::debug_assert`][crate::Command::debug_assert]:\n```rust,no_run\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n\n#[test]\nfn verify_cli() {\n    use clap::CommandFactory;\n    Cli::command().debug_assert();\n}\n```\n\n## Next Steps\n\n- [Cookbook][crate::_cookbook] for application-focused examples\n- Explore more features in the [Derive reference][super]\n  - See also [`Command`], [`Arg`], [`ArgGroup`], and [`PossibleValue`] builder functions which\n    can be used as attributes\n\nFor support, see [Discussions](https://github.com/clap-rs/clap/discussions)"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/repl_derive.rs",
      "content": "# Example: REPL (Derive API)\n\n```rust\nuse std::io::Write;\n\nuse clap::{Parser, Subcommand};\n\nfn main() -> Result<(), String> {\n    loop {\n        let line = readline()?;\n        let line = line.trim();\n        if line.is_empty() {\n            continue;\n        }\n\n        match respond(line) {\n            Ok(quit) => {\n                if quit {\n                    break;\n                }\n            }\n            Err(err) => {\n                write!(std::io::stdout(), \"{err}\").map_err(|e| e.to_string())?;\n                std::io::stdout().flush().map_err(|e| e.to_string())?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn respond(line: &str) -> Result<bool, String> {\n    let args = shlex::split(line).ok_or(\"error: Invalid quoting\")?;\n    let cli = Cli::try_parse_from(args).map_err(|e| e.to_string())?;\n    match cli.command {\n        Commands::Ping => {\n            write!(std::io::stdout(), \"Pong\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n        }\n        Commands::Exit => {\n            write!(std::io::stdout(), \"Exiting ...\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n            return Ok(true);\n        }\n    }\n    Ok(false)\n}\n\n#[derive(Debug, Parser)]\n#[command(multicall = true)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    Ping,\n    Exit,\n}\n\nfn readline() -> Result<String, String> {\n    write!(std::io::stdout(), \"$ \").map_err(|e| e.to_string())?;\n    std::io::stdout().flush().map_err(|e| e.to_string())?;\n    let mut buffer = String::new();\n    std::io::stdin()\n        .read_line(&mut buffer)\n        .map_err(|e| e.to_string())?;\n    Ok(buffer)\n}"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/cargo_example.rs",
      "content": "# Example: cargo subcommand (Builder API)\n\n```rust\nfn main() {\n    let cmd = clap::Command::new(\"cargo\")\n        .bin_name(\"cargo\")\n        .styles(CLAP_STYLING)\n        .subcommand_required(true)\n        .subcommand(\n            clap::command!(\"example\").arg(\n                clap::arg!(--\"manifest-path\" <PATH>)\n                    .value_parser(clap::value_parser!(std::path::PathBuf)),\n            ),\n        );\n    let matches = cmd.get_matches();\n    let matches = match matches.subcommand() {\n        Some((\"example\", matches)) => matches,\n        _ => unreachable!(\"clap should ensure we don't get here\"),\n    };\n    let manifest_path = matches.get_one::<std::path::PathBuf>(\"manifest-path\");\n    println!(\"{manifest_path:?}\");\n}\n\n// See also `clap_cargo::style::CLAP_STYLING`\npub const CLAP_STYLING: clap::builder::styling::Styles = clap::builder::styling::Styles::styled()\n    .header(clap_cargo::style::HEADER)\n    .usage(clap_cargo::style::USAGE)\n    .literal(clap_cargo::style::LITERAL)\n    .placeholder(clap_cargo::style::PLACEHOLDER)\n    .error(clap_cargo::style::ERROR)\n    .valid(clap_cargo::style::VALID)\n    .invalid(clap_cargo::style::INVALID);\n```\n\nFor more on creating a custom subcommand, see [the cargo\nbook](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).\nThe crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in\nmimicking cargo's interface.\n\nThe help looks like:\n```console\n$ cargo-example --help\nUsage: cargo <COMMAND>\n\nCommands:\n  example  A simple to use, efficient, and full-featured Command Line Argument Parser\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ cargo-example example --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: cargo example [OPTIONS]\n\nOptions:\n      --manifest-path <PATH>  \n  -h, --help                  Print help\n  -V, --version               Print version\n\n```\n\nThen to directly invoke the command, run:\n```console\n$ cargo-example example\nNone\n\n$ cargo-example example --manifest-path Cargo.toml\nSome(\"Cargo.toml\")\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/typed_derive.rs",
      "content": "# Example: Custom Types (Derive API)\n\n```rust\nuse clap::builder::TypedValueParser as _;\nuse clap::Parser;\nuse std::error::Error;\n\n#[derive(Parser, Debug)] // requires `derive` feature\n#[command(term_width = 0)] // Just to make testing across clap features easier\nstruct Args {\n    /// Implicitly using `std::str::FromStr`\n    #[arg(short = 'O')]\n    optimization: Option<usize>,\n\n    /// Allow invalid UTF-8 paths\n    #[arg(short = 'I', value_name = \"DIR\", value_hint = clap::ValueHint::DirPath)]\n    include: Option<std::path::PathBuf>,\n\n    /// Handle IP addresses\n    #[arg(long)]\n    bind: Option<std::net::IpAddr>,\n\n    /// Allow human-readable durations\n    #[arg(long)]\n    sleep: Option<jiff::SignedDuration>,\n\n    /// Hand-written parser for tuples\n    #[arg(short = 'D', value_parser = parse_key_val::<String, i32>)]\n    defines: Vec<(String, i32)>,\n\n    /// Support for discrete numbers\n    #[arg(\n        long,\n        default_value_t = 22,\n        value_parser = clap::builder::PossibleValuesParser::new([\"22\", \"80\"])\n            .map(|s| s.parse::<usize>().unwrap()),\n    )]\n    port: usize,\n\n    /// Support enums from a foreign crate that don't implement `ValueEnum`\n    #[arg(\n        long,\n        default_value_t = foreign_crate::LogLevel::Info,\n        value_parser = clap::builder::PossibleValuesParser::new([\"trace\", \"debug\", \"info\", \"warn\", \"error\"])\n            .map(|s| s.parse::<foreign_crate::LogLevel>().unwrap()),\n    )]\n    log_level: foreign_crate::LogLevel,\n}\n\n/// Parse a single key-value pair\nfn parse_key_val<T, U>(s: &str) -> Result<(T, U), Box<dyn Error + Send + Sync + 'static>>\nwhere\n    T: std::str::FromStr,\n    T::Err: Error + Send + Sync + 'static,\n    U: std::str::FromStr,\n    U::Err: Error + Send + Sync + 'static,\n{\n    let pos = s\n        .find('=')\n        .ok_or_else(|| format!(\"invalid KEY=value: no `=` found in `{s}`\"))?;\n    Ok((s[..pos].parse()?, s[pos + 1..].parse()?))\n}\n\nmod foreign_crate {\n    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n    pub(crate) enum LogLevel {\n        Trace,\n        Debug,\n        Info,\n        Warn,\n        Error,\n    }\n\n    impl std::fmt::Display for LogLevel {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            let s = match self {\n                Self::Trace => \"trace\",\n                Self::Debug => \"debug\",\n                Self::Info => \"info\",\n                Self::Warn => \"warn\",\n                Self::Error => \"error\",\n            };\n            s.fmt(f)\n        }\n    }\n    impl std::str::FromStr for LogLevel {\n        type Err = String;\n\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            match s {\n                \"trace\" => Ok(Self::Trace),\n                \"debug\" => Ok(Self::Debug),\n                \"info\" => Ok(Self::Info),\n                \"warn\" => Ok(Self::Warn),\n                \"error\" => Ok(Self::Error),\n                _ => Err(format!(\"Unknown log level: {s}\")),\n            }\n        }\n    }\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"{args:?}\");\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nHelp:\n```console\n$ typed-derive --help\nUsage: typed-derive[EXE] [OPTIONS]\n\nOptions:\n  -O <OPTIMIZATION>            Implicitly using `std::str::FromStr`\n  -I <DIR>                     Allow invalid UTF-8 paths\n      --bind <BIND>            Handle IP addresses\n      --sleep <SLEEP>          Allow human-readable durations\n  -D <DEFINES>                 Hand-written parser for tuples\n      --port <PORT>            Support for discrete numbers [default: 22] [possible values: 22, 80]\n      --log-level <LOG_LEVEL>  Support enums from a foreign crate that don't implement `ValueEnum` [default: info] [possible values: trace, debug, info, warn, error]\n  -h, --help                   Print help\n\n```\n\nOptimization-level (number)\n```console\n$ typed-derive -O 1\nArgs { optimization: Some(1), include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive -O plaid\n? failed\nerror: invalid value 'plaid' for '-O <OPTIMIZATION>': invalid digit found in string\n\nFor more information, try '--help'.\n\n```\n\nInclude (path)\n```console\n$ typed-derive -I../hello\nArgs { optimization: None, include: Some(\"../hello\"), bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n```\n\nIP Address\n```console\n$ typed-derive --bind 192.0.0.1\nArgs { optimization: None, include: None, bind: Some(192.0.0.1), sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive --bind localhost\n? failed\nerror: invalid value 'localhost' for '--bind <BIND>': invalid IP address syntax\n\nFor more information, try '--help'.\n\n```\n\nTime\n```console\n$ typed-derive --sleep 10s\nArgs { optimization: None, include: None, bind: None, sleep: Some(10s), defines: [], port: 22, log_level: Info }\n\n$ typed-derive --sleep forever\n? failed\nerror: invalid value 'forever' for '--sleep <SLEEP>': failed to parse \"forever\" in the \"friendly\" format: parsing a friendly duration requires it to start with a unit value (a decimal integer) after an optional sign, but no integer was found\n\nFor more information, try '--help'.\n\n```\n\nDefines (key-value pairs)\n```console\n$ typed-derive -D Foo=10 -D Alice=30\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [(\"Foo\", 10), (\"Alice\", 30)], port: 22, log_level: Info }\n\n$ typed-derive -D Foo\n? failed\nerror: invalid value 'Foo' for '-D <DEFINES>': invalid KEY=value: no `=` found in `Foo`\n\nFor more information, try '--help'.\n\n$ typed-derive -D Foo=Bar\n? failed\nerror: invalid value 'Foo=Bar' for '-D <DEFINES>': invalid digit found in string\n\nFor more information, try '--help'.\n\n```\n\nDiscrete numbers\n```console\n$ typed-derive --port 22\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive --port 80\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 80, log_level: Info }\n\n$ typed-derive --port\n? failed\nerror: a value is required for '--port <PORT>' but none was supplied\n  [possible values: 22, 80]\n\nFor more information, try '--help'.\n\n$ typed-derive --port 3000\n? failed\nerror: invalid value '3000' for '--port <PORT>'\n  [possible values: 22, 80]\n\nFor more information, try '--help'.\n\n```\n\nEnums from crates that can't implement `ValueEnum`\n```console\n$ typed-derive --log-level debug\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Debug }\n\n$ typed-derive --log-level error\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Error }\n\n$ typed-derive --log-level\n? failed\nerror: a value is required for '--log-level <LOG_LEVEL>' but none was supplied\n  [possible values: trace, debug, info, warn, error]\n\nFor more information, try '--help'.\n\n$ typed-derive --log-level critical\n? failed\nerror: invalid value 'critical' for '--log-level <LOG_LEVEL>'\n  [possible values: trace, debug, info, warn, error]\n\nFor more information, try '--help'.\n\n```"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_features.rs",
      "content": "## Documentation: Feature Flags\n\nAvailable [compile-time feature flags](https://doc.rust-lang.org/cargo/reference/features.html#dependency-features)\n\n#### Default Features\n\n* `std`: _Not Currently Used._ Placeholder for supporting `no_std` environments in a backwards compatible manner.\n* `color`: Turns on terminal styling of help and error messages.  See\n  [`Command::styles`][crate::Command::styles] to customize this.\n* `help`: Auto-generate help output\n* `usage`: Auto-generate usage\n* `error-context`: Include contextual information for errors (which arg failed, etc)\n* `suggestions`: Turns on the `Did you mean '--myoption'?` feature for when users make typos.\n\n#### Optional features\n\n* `deprecated`: Guided experience to prepare for next breaking release (at different stages of development, this may become default)\n* `derive`: Enables the custom derive (i.e. `#[derive(Parser)]`). Without this you must use one of the other methods of creating a `clap` CLI listed above.\n* `cargo`: Turns on macros that read values from [`CARGO_*` environment variables](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates).\n* `env`: Turns on the usage of environment variables during parsing.\n* `unicode`: Turns on support for unicode characters (including emoji) in arguments and help messages.\n* ``wrap_help``: Turns on the help text wrapping feature, based on the terminal size.\n* `string`: Allow runtime generated strings (e.g. with [`Str`][crate::builder::Str]).\n\n#### Experimental features\n\n**Warning:** These may contain breaking changes between minor releases.\n\n* `unstable-v5`: Preview features which will be stable on the v5.0 release"
    },
    {
      "link": "https://docs.rs/crate/clap/4.5.39/source/src/_cookbook/escaped_positional_derive.rs",
      "content": "# Example (Derive API)\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)] // requires `derive` feature\n#[command(version, about, long_about = None)]\nstruct Cli {\n    #[arg(short = 'f')]\n    eff: bool,\n\n    #[arg(short = 'p', value_name = \"PEAR\")]\n    pea: Option<String>,\n\n    #[arg(last = true)]\n    slop: Vec<String>,\n}\n\nfn main() {\n    let args = Cli::parse();\n\n    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...\n    println!(\"-f used: {:?}\", args.eff); // -f used: true\n    println!(\"-p's value: {:?}\", args.pea); // -p's value: Some(\"bob\")\n    println!(\"'slops' values: {:?}\", args.slop); // 'slops' values: Some([\"sloppy\", \"slop\", \"slop\"])\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nYou can use `--` to escape further arguments.\n\nLet's see what this looks like in the help:\n```console\n$ escaped-positional-derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]\n\nArguments:\n  [SLOP]...  \n\nOptions:\n  -f             \n  -p <PEAR>      \n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nHere is a baseline without any arguments:\n```console\n$ escaped-positional-derive\n-f used: false\n-p's value: None\n'slops' values: []\n\n```\n\nNotice that we can't pass positional arguments before `--`:\n```console\n$ escaped-positional-derive foo bar\n? failed\nerror: unexpected argument 'foo' found\n\nUsage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]\n\nFor more information, try '--help'.\n\n```\n\nBut you can after:\n```console\n$ escaped-positional-derive -f -p=bob -- sloppy slop slop\n-f used: true\n-p's value: Some(\"bob\")\n'slops' values: [\"sloppy\", \"slop\", \"slop\"]\n\n```\n\nAs mentioned, the parser will directly pass everything through:\n```console\n$ escaped-positional-derive -- -f -p=bob sloppy slop slop\n-f used: false\n-p's value: None\n'slops' values: [\"-f\", \"-p=bob\", \"sloppy\", \"slop\", \"slop\"]\n\n```"
    }
  ]
}